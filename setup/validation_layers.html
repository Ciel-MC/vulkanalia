<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Validation layers - Vulkan Tutorial (Rust)</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="../development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="../faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="../setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="../setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="../setup/validation_layers.html" class="active"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="../setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="../setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="../presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="../presentation/swapchain.html"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="../presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="../pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="../pipeline/fixed_functions.html"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="../pipeline/render_passes.html"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="../pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="../drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="../drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="../drawing/rendering_and_presentation.html"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="../swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="../vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="../vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="../vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="../vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="../uniform/descriptor_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor layout and buffer</a></li><li class="chapter-item expanded "><a href="../uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="../texture/images.html"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="../texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="../texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="../model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="../model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced</li><li class="chapter-item expanded "><a href="../advanced/generating_mipmaps.html"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="../advanced/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#validation-layers" id="validation-layers">Validation layers</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/02_validation_layers.rs">main.rs</a></p>
<h2><a class="header" href="#what-are-validation-layers" id="what-are-validation-layers">What are validation layers?</a></h2>
<p>The Vulkan API is designed around the idea of minimal driver overhead and one of the manifestations of that goal is that there is very limited error checking in the API by default. Even mistakes as simple as setting enumerations to incorrect values are generally not explicitly handled and will simply result in crashes or undefined behavior. Because Vulkan requires you to be very explicit about everything you're doing, it's easy to make many small mistakes like using a new GPU feature and forgetting to request it at logical device creation time.</p>
<p>However, that doesn't mean that these checks can't be added to the API. Vulkan introduces an elegant system for this known as validation layers. Validation layers are optional components that hook into Vulkan function calls to apply additional operations. Common operations in validation layers are:</p>
<ul>
<li>Checking the values of parameters against the specification to detect misuse</li>
<li>Tracking creation and destruction of objects to find resource leaks</li>
<li>Checking thread safety by tracking the threads that calls originate from</li>
<li>Logging every call and its parameters to the standard output</li>
<li>Tracing Vulkan calls for profiling and replaying</li>
</ul>
<p>Here's an example of what the implementation of a function in a diagnostics validation layer could look like (in C):</p>
<pre><code class="language-c">VkResult vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* instance
) {
    if (pCreateInfo == nullptr || instance == nullptr) {
        log(&quot;Null pointer passed to required parameter!&quot;);
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    return real_vkCreateInstance(pCreateInfo, pAllocator, instance);
}
</code></pre>
<p>These validation layers can be freely stacked to include all the debugging functionality that you're interested in. You can simply enable validation layers for debug builds and completely disable them for release builds, which gives you the best of both worlds!</p>
<p>Vulkan does not come with any validation layers built-in, but the LunarG Vulkan SDK provides a nice set of layers that check for common errors. They're also completely <a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers">open source</a>, so you can check which kind of mistakes they check for and contribute. Using the validation layers is the best way to avoid your application breaking on different drivers by accidentally relying on undefined behavior.</p>
<p>Validation layers can only be used if they have been installed onto the system. For example, the LunarG validation layers are only available on PCs with the Vulkan SDK installed.</p>
<p>There were formerly two different types of validation layers in Vulkan: instance and device specific. The idea was that instance layers would only check calls related to global Vulkan objects like instances, and device specific layers would only check calls related to a specific GPU. Device specific layers have now been deprecated, which means that instance validation layers apply to all Vulkan calls. The specification document still recommends that you enable validation layers at device level as well for compatibility, which is required by some implementations. We'll simply specify the same layers as the instance at logical device level, which we'll see later on.</p>
<p>Before we get started, we'll need some new imports for this chapter:</p>
<pre><code class="language-rust noplaypen">use std::collections::HashSet;
use std::ffi::CStr;
use std::os::raw::c_void;

use log::*;
</code></pre>
<p><code>HashSet</code> will be used for storing and querying supported layers and the other imports will be used in the function we will be writing to log messages from the validation layer.</p>
<h2><a class="header" href="#using-validation-layers" id="using-validation-layers">Using validation layers</a></h2>
<p>In this section we'll see how to enable the standard diagnostics layers provided by the Vulkan SDK. Just like extensions, validation layers need to be enabled by specifying their name. All of the useful standard validation is bundled into a layer included in the SDK that is known as <code>VK_LAYER_KHRONOS_validation</code>.</p>
<p>Let's first add two configuration variables to the program to specify the layers to enable and whether to enable them or not. I've chosen to base that value on whether the program is being compiled in debug mode or not.</p>
<pre><code class="language-rust noplaypen">const VALIDATION_ENABLED: bool =
    cfg!(debug_assertions);

const VALIDATION_LAYER: vk::ExtensionName =
    vk::to_extension_name(b&quot;VK_LAYER_KHRONOS_validation\0&quot;);
</code></pre>
<p>We'll add some new code to our <code>create_instance</code> function that collects the supported instance layers into a <code>HashSet</code>, checks that the validation layer is available, and creates a list of layer names containing the validation layer. This code should go right below where the <code>vk::ApplicationInfo</code> struct is built:</p>
<pre><code class="language-rust noplaypen">let available_layers = entry
    .enumerate_instance_layer_properties()?
    .iter()
    .map(|l| l.layer_name)
    .collect::&lt;HashSet&lt;_&gt;&gt;();

if VALIDATION_ENABLED &amp;&amp; !available_layers.contains(&amp;VALIDATION_LAYER) {
    return Err(anyhow!(&quot;Validation layer requested but not supported.&quot;));
}

let layers = if VALIDATION_ENABLED {
    vec![VALIDATION_LAYER.to_cstr().as_ptr()]
} else {
    Vec::new()
};
</code></pre>
<p>Then you'll need to specify the requested layers in <code>vk::CreateInstanceInfo</code> by adding a call to the <code>enabled_layer_names</code> builder method:</p>
<pre><code class="language-rust noplaypen">let info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions);
</code></pre>
<p>Now run the program in debug mode and ensure that the <code>Validation layer requested but not supported.</code> error does not occur. If it does, then have a look at the FAQ. If you get past that check, then <code>entry.create_instance(...)</code> should never return a <code>vk::Result::ERROR_LAYER_NOT_PRESENT</code> error but you should still run the program to be sure.</p>
<h2><a class="header" href="#message-callback" id="message-callback">Message callback</a></h2>
<p>The validation layers will print debug messages to the standard output by default, but we can also handle them ourselves by providing an explicit callback in our program. This will also allow you to decide which kind of messages you would like to see, because not all are necessarily (fatal) errors. If you don't want to do that right now then you may skip to the last section in this chapter.</p>
<p>To set up a callback in the program to handle messages and the associated details, we have to set up a debug messenger with a callback using the <code>VK_EXT_debug_utils</code> extension.</p>
<p>We'll add some more code to our <code>create_instance</code> function. This time we'll modify the <code>extensions</code> list to be mutable and then add the debug utilities extension to the list when the validation layer is enabled:</p>
<pre><code class="language-rust noplaypen">let mut extensions = vk_winit::get_required_instance_extensions(entry)?
    .iter()
    .map(|e| e.to_cstr().as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();

if VALIDATION_ENABLED {
    extensions.push(vk::EXT_DEBUG_UTILS_EXTENSION.to_cstr().as_ptr());
}
</code></pre>
<p>Run the program to make sure you don't receive a <code>vk::Result::ERROR_EXTENSION_NOT_PRESENT</code> error. We don't really need to check for the existence of this extension, because it should be implied by the availability of the validation layers.</p>
<p>Now let's see what a debug callback function looks like. Add a new <code>extern &quot;system&quot;</code> function called <code>debugCallback</code> with the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/type.PFN_vkDebugUtilsMessengerCallbackEXT.html"><code>PFN_vkDebugUtilsMessengerCallbackEXT</code></a> prototype. The <code>extern &quot;system&quot;</code> is necessary to support Vulkan calling it from C.</p>
<pre><code class="language-rust noplaypen">extern &quot;system&quot; fn debug_callback(
    severity: vk::DebugUtilsMessageSeverityFlagsEXT,
    type_: vk::DebugUtilsMessageTypeFlagsEXT,
    data: *const vk::DebugUtilsMessengerCallbackDataEXT,
    _: *mut c_void,
) -&gt; vk::Bool32 {
    let data = unsafe { *data };
    let message = unsafe { CStr::from_ptr(data.message) }.to_string_lossy();

    if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::ERROR {
        error!(&quot;({:?}) {}&quot;, type_, message);
    } else if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::WARNING {
        warn!(&quot;({:?}) {}&quot;, type_, message);
    } else if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::INFO {
        debug!(&quot;({:?}) {}&quot;, type_, message);
    } else {
        trace!(&quot;({:?}) {}&quot;, type_, message);
    }

    vk::FALSE
}
</code></pre>
<p>The first parameter specifies the severity of the message, which is one of the following flags:</p>
<ul>
<li><code>vk::DebugUtilsMessageSeverityFlagsEXT::VERBOSE</code>: Diagnostic message</li>
<li><code>vk::DebugUtilsMessageSeverityFlagsEXT::INFO</code>: Informational message like the creation of a resource</li>
<li><code>vk::DebugUtilsMessageSeverityFlagsEXT::WARNING</code>: Message about behavior that is not necessarily an error, but very likely a bug in your application</li>
<li><code>vk::DebugUtilsMessageSeverityFlagsEXT::ERROR</code>: Message about behavior that is invalid and may cause crashes</li>
</ul>
<p>The values of this enumeration are set up in such a way that you can use a comparison operation to check if a message is equal or worse compared to some level of severity which we use here to decide on which <code>log</code> macro is appropriate to use when logging the message.</p>
<p>The <code>type_</code> parameter can have the following values:</p>
<ul>
<li><code>vk::DebugUtilsMessageTypeFlagsEXT::GENERAL</code>: Some event has happened that is unrelated to the specification or performance</li>
<li><code>vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION</code>: Something has happened that violates the specification or indicates a possible mistake</li>
<li><code>vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE</code>: Potential non-optimal use of Vulkan</li>
</ul>
<p>The <code>pCallbackData</code> parameter refers to a <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.DebugUtilsMessengerCallbackDataEXT.html"><code>vk::DebugUtilsMessengerCallbackDataEXT</code></a> struct containing the details of the message itself, with the most important members being:</p>
<ul>
<li><code>message</code>: The debug message as a null-terminated string (<code>*const c_char</code>)</li>
<li><code>objects</code>: Array of Vulkan object handles related to the message</li>
<li><code>object_count</code>: Number of objects in array</li>
</ul>
<p>Finally, the last parameter, here ignored as <code>_</code>, contains a pointer that was specified during the setup of the callback and allows you to pass your own data to it.</p>
<p>The callback returns a (Vulkan) boolean that indicates if the Vulkan call that triggered the validation layer message should be aborted. If the callback returns true, then the call is aborted with the <code>vk::Result::ERROR_VALIDATION_FAILED_EXT</code> error. This is normally only used to test the validation layers themselves, so you should always return <code>vk::FALSE</code>.</p>
<p>All that remains now is telling Vulkan about the callback function. We'll accomplish this by <em>extending</em> the <code>vk::InstanceCreateInfo</code> struct we used to create the Vulkan instance in the <code>create_instance</code> function with additional instance creation information.</p>
<h2><a class="header" href="#adding-the-debug-callback" id="adding-the-debug-callback">Adding the debug callback</a></h2>
<p>The <code>s_type</code> field that is present on many Vulkan structs was briefly mentioned in the <a href="../overview.html#builders">Builders section</a> of the Overview chapter. It was said that this field must be set to the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.StructureType.html"><code>vk::StructureType</code></a> enum value indicating the type of the struct (e.g., <code>vk::StructureType::APPLICATION_INFO</code> for a <code>vk::ApplicationInfo</code> struct).</p>
<p>You may have wondered what the purpose of this field is; doesn't Vulkan already know the type of structs passed to its commands? The purpose of this field is wrapped up with the purpose of the <code>next</code> field that always accompanies the <code>s_type</code> field in Vulkan structs: the ability to <em>extend</em> a Vulkan struct with other Vulkan structs.</p>
<p>The <code>next</code> field in a Vulkan struct may be used to specify a <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fundamentals-validusage-pNext">structure pointer chain</a>. <code>next</code> can be either be null or a pointer to a Vulkan struct that is permitted by Vulkan to extend the struct. Each struct in this chain of structs is used to provide additional information to the Vulkan command the root structure is passed to. This feature of Vulkan allows for extending the functionality of Vulkan commands without breaking backwards compabilitity.</p>
<p>When you pass such a chain of structs to a Vulkan command, it must iterate through the structs to collect all of the information from the structs. Because of this, Vulkan can't know the type of each structure in the chain, hence the need for the <code>s_type</code> field.</p>
<p>The builder structs provided by <code>vulkanalia</code> allow for easily building these pointer chains in a type-safe manner. For example, take a look at the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.InstanceCreateInfoBuilder.html"><code>vk::InstanceCreateInfoBuilder</code></a> builder struct, specifically the <code>push_next</code> method. This method allows adding any Vulkan struct for which the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.ExtendsInstanceCreateInfo.html"><code>vk::ExtendsInstanceCreateInfo</code></a> trait is implemented for to the pointer chain for a <code>vk::InstanceCreateInfo</code>.</p>
<p>One such struct is <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code>vk::DebugUtilsMessengerCreateInfoEXT</code></a>, which we will now use to extend our <code>vk::InstanceCreateInfo</code> struct to set up our debug callback. To do this we'll continue to modify our <code>create_instance</code> function, this time making the <code>info</code> variable mutable and then building and pushing a <code>vk::DebugUtilsMessengerCreateInfoEXT</code> struct onto its pointer chain:</p>
<pre><code class="language-rust noplaypen">let mut info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions);

let mut debug_info = vk::DebugUtilsMessengerCreateInfoEXT::builder()
    .message_severity(vk::DebugUtilsMessageSeverityFlagsEXT::all())
    .message_type(vk::DebugUtilsMessageTypeFlagsEXT::all())
    .user_callback(Some(debug_callback));

if VALIDATION_ENABLED {
    info = info.push_next(&amp;mut debug_info);
}
</code></pre>
<p><code>debug_info</code> needs to be defined outside of the conditional since it needs to live until we are done calling <code>entry.create_instance(...)</code>. Fortunately we can rely on the Rust compiler to protect us from pushing a struct that doesn't live long enough onto a pointer chain due to the lifetimes defined for the <code>vulkanalia</code> builder structs.</p>
<p>Now we should be able to run our program and see logs from our debug callback, but first we'll need to set the <code>RUST_LOG</code> environment variable so that <code>pretty_env_logger</code> will enable the log levels we are interested in. Initially set the log level to <code>debug</code> so we can be sure it is working, here is an example on Windows (Powershell):</p>
<p><img src="../images/validation_layer_test.png" alt="" /></p>
<p>If everything is working you shouldn't see any warning or error messages. Going forward you may want to increase the minimum log level to <code>info</code> using <code>RUST_LOG</code> to reduce the verbosity of the logs unless you are trying to debug an error.</p>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<p>There are a lot more settings for the behavior of validation layers than just
the flags specified in the <code>vk::DebugUtilsMessengerCreateInfoEXT</code> struct. Browse
to the Vulkan SDK and go to the <code>Config</code> directory. There you will find a
<code>vk_layer_settings.txt</code> file that explains how to configure the layers.</p>
<p>To configure the layer settings for your own application, copy the file to the
working directory of your project's executable and follow the instructions to
set the desired behavior. However, for the remainder of this tutorial I'll
assume that you're using the default settings.</p>
<p>Throughout this tutorial I'll be making a couple of intentional mistakes to show
you how helpful the validation layers are with catching them and to teach you
how important it is to know exactly what you're doing with Vulkan. Now it's time
to look at Vulkan devices in the system.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../setup/instance.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../setup/physical_devices_and_queue_families.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../setup/instance.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../setup/physical_devices_and_queue_families.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
