<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Vulkan Tutorial (Rust)</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Overview</a></li><li class="chapter-item expanded "><a href="development_environment.html"><strong aria-hidden="true">3.</strong> Development environment</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">4.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Setup</li><li class="chapter-item expanded "><a href="setup/base_code.html"><strong aria-hidden="true">5.</strong> Base code</a></li><li class="chapter-item expanded "><a href="setup/instance.html"><strong aria-hidden="true">6.</strong> Instance</a></li><li class="chapter-item expanded "><a href="setup/validation_layers.html"><strong aria-hidden="true">7.</strong> Validation layers</a></li><li class="chapter-item expanded "><a href="setup/physical_devices_and_queue_families.html"><strong aria-hidden="true">8.</strong> Physical devices and queue families</a></li><li class="chapter-item expanded "><a href="setup/logical_device_and_queues.html"><strong aria-hidden="true">9.</strong> Logical device and queues</a></li><li class="chapter-item expanded affix "><li class="part-title">Presentation</li><li class="chapter-item expanded "><a href="presentation/window_surface.html"><strong aria-hidden="true">10.</strong> Window surface</a></li><li class="chapter-item expanded "><a href="presentation/swapchain.html"><strong aria-hidden="true">11.</strong> Swapchain</a></li><li class="chapter-item expanded "><a href="presentation/image_views.html"><strong aria-hidden="true">12.</strong> Image views</a></li><li class="chapter-item expanded affix "><li class="part-title">Pipeline</li><li class="chapter-item expanded "><a href="pipeline/introduction.html"><strong aria-hidden="true">13.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="pipeline/shader_modules.html"><strong aria-hidden="true">14.</strong> Shader modules</a></li><li class="chapter-item expanded "><a href="pipeline/fixed_functions.html"><strong aria-hidden="true">15.</strong> Fixed functions</a></li><li class="chapter-item expanded "><a href="pipeline/render_passes.html"><strong aria-hidden="true">16.</strong> Render passes</a></li><li class="chapter-item expanded "><a href="pipeline/conclusion.html"><strong aria-hidden="true">17.</strong> Conclusion</a></li><li class="chapter-item expanded affix "><li class="part-title">Drawing</li><li class="chapter-item expanded "><a href="drawing/framebuffers.html"><strong aria-hidden="true">18.</strong> Framebuffers</a></li><li class="chapter-item expanded "><a href="drawing/command_buffers.html"><strong aria-hidden="true">19.</strong> Command buffers</a></li><li class="chapter-item expanded "><a href="drawing/rendering_and_presentation.html"><strong aria-hidden="true">20.</strong> Rendering and presentation</a></li><li class="chapter-item expanded affix "><li class="part-title">Swapchain</li><li class="chapter-item expanded "><a href="swapchain/recreation.html"><strong aria-hidden="true">21.</strong> Recreation</a></li><li class="chapter-item expanded affix "><li class="part-title">Vertex buffers</li><li class="chapter-item expanded "><a href="vertex/vertex_input_description.html"><strong aria-hidden="true">22.</strong> Vertex input description</a></li><li class="chapter-item expanded "><a href="vertex/vertex_buffer_creation.html"><strong aria-hidden="true">23.</strong> Vertex buffer creation</a></li><li class="chapter-item expanded "><a href="vertex/staging_buffer.html"><strong aria-hidden="true">24.</strong> Staging buffer</a></li><li class="chapter-item expanded "><a href="vertex/index_buffer.html"><strong aria-hidden="true">25.</strong> Index buffer</a></li><li class="chapter-item expanded affix "><li class="part-title">Uniform buffers</li><li class="chapter-item expanded "><a href="uniform/descriptor_layout_and_buffer.html"><strong aria-hidden="true">26.</strong> Descriptor layout and buffer</a></li><li class="chapter-item expanded "><a href="uniform/descriptor_pool_and_sets.html"><strong aria-hidden="true">27.</strong> Descriptor pool and sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Texture mapping</li><li class="chapter-item expanded "><a href="texture/images.html"><strong aria-hidden="true">28.</strong> Images</a></li><li class="chapter-item expanded "><a href="texture/image_view_and_sampler.html"><strong aria-hidden="true">29.</strong> Image view and sampler</a></li><li class="chapter-item expanded "><a href="texture/combined_image_sampler.html"><strong aria-hidden="true">30.</strong> Combined image sampler</a></li><li class="chapter-item expanded affix "><li class="part-title">Model</li><li class="chapter-item expanded "><a href="model/depth_buffering.html"><strong aria-hidden="true">31.</strong> Depth buffering</a></li><li class="chapter-item expanded "><a href="model/loading_models.html"><strong aria-hidden="true">32.</strong> Loading models</a></li><li class="chapter-item expanded affix "><li class="part-title">Advanced</li><li class="chapter-item expanded "><a href="advanced/generating_mipmaps.html"><strong aria-hidden="true">33.</strong> Generating mipmaps</a></li><li class="chapter-item expanded "><a href="advanced/multisampling.html"><strong aria-hidden="true">34.</strong> Multisampling</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Vulkan Tutorial (Rust)</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>This tutorial is an adaptation of <a href="https://vulkan-tutorial.com">https://vulkan-tutorial.com</a> to use Rust instead of C/C++.</p>
<p>The vast majority of the credit for this tutorial should go the author of <a href="https://vulkan-tutorial.com">https://vulkan-tutorial.com</a>, <a href="https://github.com/Overv">Alexander Overvoorde</a>.</p>
<h2><a class="header" href="#about" id="about">About</a></h2>
<p>This tutorial will teach you the basics of using the <a href="https://www.khronos.org/vulkan/">Vulkan</a> graphics and compute API. Vulkan is a new API by the <a href="https://www.khronos.org/">Khronos group</a> (known for OpenGL) that provides a much better abstraction of modern graphics cards. This new interface allows you to better describe what your application intends to do, which can lead to better performance and less surprising driver behavior compared to existing APIs like <a href="https://en.wikipedia.org/wiki/OpenGL">OpenGL</a> and <a href="https://en.wikipedia.org/wiki/Direct3D">Direct3D</a>. The ideas behind Vulkan are similar to those of <a href="https://en.wikipedia.org/wiki/Direct3D#Direct3D_12">Direct3D 12</a> and <a href="https://en.wikipedia.org/wiki/Metal_(API)">Metal</a>, but Vulkan has the advantage of being fully cross-platform and allows you to develop for Windows, Linux and Android at the same time (and iOS and macOS via <a href="https://github.com/KhronosGroup/MoltenVK">MoltenVK</a>).</p>
<p>However, the price you pay for these benefits is that you have to work with a significantly more verbose API. Every detail related to the graphics API needs to be set up from scratch by your application, including initial frame buffer creation and memory management for objects like buffers and texture images. The graphics driver will do a lot less hand holding, which means that you will have to do more work in your application to ensure correct behavior.</p>
<p>The takeaway message here is that Vulkan is not for everyone. It is targeted at programmers who are enthusiastic about high performance computer graphics, and are willing to put some work in. If you are more interested in game development, rather than computer graphics, then you may wish to stick to OpenGL or Direct3D, which will not be deprecated in favor of Vulkan anytime soon. Another alternative is to use an engine like <a href="https://en.wikipedia.org/wiki/Unreal_Engine#Unreal_Engine_4">Unreal Engine</a> or <a href="https://en.wikipedia.org/wiki/Unity_(game_engine)">Unity</a>, which will be able to use Vulkan while exposing a much higher level API to you.</p>
<p>With that out of the way, let's cover some prerequisites for following this tutorial:</p>
<ul>
<li>A graphics card and driver compatible with Vulkan (<a href="https://developer.nvidia.com/vulkan-driver">NVIDIA</a>, <a href="http://www.amd.com/en-us/innovations/software-technologies/technologies-gaming/vulkan">AMD</a>, <a href="https://software.intel.com/en-us/blogs/2016/03/14/new-intel-vulkan-beta-1540204404-graphics-driver-for-windows-78110-1540">Intel</a>)</li>
<li>Experience with Rust</li>
<li>Rust 1.47 or later</li>
<li>Some existing experience with 3D computer graphics</li>
</ul>
<p>This tutorial will not assume knowledge of OpenGL or Direct3D concepts, but it does require you to know the basics of 3D computer graphics. It will not explain the math behind perspective projection, for example. See <a href="https://paroj.github.io/gltut/">this online book</a> for a great introduction of computer graphics concepts. Some other great computer graphics resources are:</p>
<ul>
<li><a href="https://github.com/petershirley/raytracinginoneweekend">Ray tracing in one weekend</a></li>
<li><a href="http://www.pbr-book.org/">Physically Based Rendering book</a></li>
<li>Vulkan being used in a real engine in the open-source <a href="https://github.com/Novum/vkQuake">Quake</a> and <a href="https://github.com/DustinHLand/vkDOOM3">DOOM 3</a></li>
</ul>
<p>If you want a C or C++ tutorial instead, see the original tutorial: <a href="https://vulkan-tutorial.com">https://vulkan-tutorial.com</a></p>
<p>This tutorial will be using the <a href="https://github.com/KyleMayes/vulkanalia"><code>vulkanalia</code></a> crate to provide access to the Vulkan API from Rust. <code>vulkanalia</code> only provides a thin wrapper over the Vulkan API to make it a bit easier to use from Rust. This means that while you should have never have any difficulty in determining exactly how your Rust programs are interacting with the Vulkan API, you will be shielded from very little of the danger and verbosity of the Vulkan API.</p>
<p>If you want a Rust Vulkan tutorial that uses a crate which provides a safe and relatively concise wrapper around the Vulkan API, see this tutorial: <a href="https://github.com/bwasty/vulkan-tutorial-rs">https://github.com/bwasty/vulkan-tutorial-rs</a></p>
<h2><a class="header" href="#tutorial-structure" id="tutorial-structure">Tutorial structure</a></h2>
<p>We'll start with an overview of how Vulkan works and the work we'll have to do to get the first triangle on the screen. The purpose of all the smaller steps will make more sense after you've understood their basic role in the whole picture. Next, we'll set up the development environment with the <a href="https://lunarg.com/vulkan-sdk/">Vulkan SDK</a>.</p>
<p>After that we'll implement all of the basic components of a Vulkan program that are necessary to render your first triangle. Each chapter will follow roughly the following structure:</p>
<ul>
<li>Introduce a new concept and its purpose</li>
<li>Use all of the relevant API calls to integrate it into your program</li>
<li>Abstract parts of it into helper functions</li>
</ul>
<p>Although each chapter is written as a follow-up on the previous one, it is also possible to read the chapters as standalone articles introducing a certain Vulkan feature. That means that the site is also useful as a reference. All of the Vulkan functions and types are linked to the specification, so you can click them to learn more. Vulkan is a very new API, so there may be some shortcomings in the specification itself. You are encouraged to submit feedback to <a href="https://github.com/KhronosGroup/Vulkan-Docs">this Khronos repository</a>.</p>
<p>As mentioned before, the Vulkan API has a rather verbose API with many parameters to give you maximum control over the graphics hardware. This causes basic operations like creating a texture to take a lot of steps that have to be repeated every time. Therefore we'll be creating our own collection of helper functions throughout the tutorial.</p>
<p>Every chapter will also conclude with a link to the full code listing up to that point. You can refer to it if you have any doubts about the structure of the code, or if you're dealing with a bug and want to compare. All of the code files have been tested on graphics cards from multiple vendors to verify correctness. Each chapter also has a comment section at the end where you can ask any questions that are relevant to the specific subject matter. Please specify your platform, driver version, source code, expected behavior and actual behavior to help us help you.</p>
<p>This tutorial is intended to be a community effort. Vulkan is still a very new API and best practices have not really been established yet. If you have any type of feedback on the tutorial and site itself, then please don't hesitate to submit an issue or pull request to the <a href="https://github.com/KyleMayes/vulkanalia">GitHub repository</a>.</p>
<p>After you've gone through the ritual of drawing your very first Vulkan powered triangle onscreen, we'll start expanding the program to include linear transformations, textures and 3D models.</p>
<p>If you've played with graphics APIs before, then you'll know that there can be a lot of steps until the first geometry shows up on the screen. There are many of these initial steps in Vulkan, but you'll see that each of the individual steps is easy to understand and does not feel redundant. It's also important to keep in mind that once you have that boring looking triangle, drawing fully textured 3D models does not take that much extra work, and each step beyond that point is much more rewarding.</p>
<p>If you encounter any problems while following the tutorial, check the FAQ to see if your problem and its solution is already listed there. Next, you might find someone who had the same problem (if it is not Rust-specific) in the comment section for the corresponding chapter in the <a href="https://vulkan-tutorial.com/">original tutorial</a>.</p>
<h1><a class="header" href="#overview" id="overview">Overview</a></h1>
<p>This chapter will start off with an introduction of Vulkan and the problems it addresses. After that we're going to look at the ingredients that are required for the first triangle. This will give you a big picture to place each of the subsequent chapters in. We will conclude by covering the structure of the Vulkan API as implemented by <code>vulkanalia</code>.</p>
<h2><a class="header" href="#origin-of-vulkan" id="origin-of-vulkan">Origin of Vulkan</a></h2>
<p>Just like the previous graphics APIs, Vulkan is designed as a cross-platform abstraction over <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">GPUs</a>. The problem with most of these APIs is that the era in which they were designed featured graphics hardware that was mostly limited to configurable fixed functionality. Programmers had to provide the vertex data in a standard format and were at the mercy of the GPU manufacturers with regards to lighting and shading options.</p>
<p>As graphics card architectures matured, they started offering more and more programmable functionality. All this new functionality had to be integrated with the existing APIs somehow. This resulted in less than ideal abstractions and a lot of guesswork on the graphics driver side to map the programmer's intent to the modern graphics architectures. That's why there are so many driver updates for improving the performance in games, sometimes by significant margins. Because of the complexity of these drivers, application developers also need to deal with inconsistencies between vendors, like the syntax that is accepted for <a href="https://en.wikipedia.org/wiki/Shader">shaders</a>. Aside from these new features, the past decade also saw an influx of mobile devices with powerful graphics hardware. These mobile GPUs have different architectures based on their energy and space requirements. One such example is <a href="https://en.wikipedia.org/wiki/Tiled_rendering">tiled rendering</a>, which would benefit from improved performance by offering the programmer more control over this functionality. Another limitation originating from the age of these APIs is limited multi-threading support, which can result in a bottleneck on the CPU side.</p>
<p>Vulkan solves these problems by being designed from scratch for modern graphics architectures. It reduces driver overhead by allowing programmers to clearly specify their intent using a more verbose API, and allows multiple threads to create and submit commands in parallel. It reduces inconsistencies in shader compilation by switching to a standardized byte code format with a single compiler. Lastly, it acknowledges the general purpose processing capabilities of modern graphics cards by unifying the graphics and compute functionality into a single API.</p>
<h2><a class="header" href="#what-it-takes-to-draw-a-triangle" id="what-it-takes-to-draw-a-triangle">What it takes to draw a triangle</a></h2>
<p>We'll now look at an overview of all the steps it takes to render a triangle in a well-behaved Vulkan program. All of the concepts introduced here will be elaborated on in the next chapters. This is just to give you a big picture to relate all of the individual components to.</p>
<h3><a class="header" href="#step-1---instance-and-physical-device-selection" id="step-1---instance-and-physical-device-selection">Step 1 - Instance and physical device selection</a></h3>
<p>A Vulkan application starts by setting up the Vulkan API through a <code>VkInstance</code>. An instance is created by describing your application and any API extensions you will be using. After creating the instance, you can query for Vulkan supported hardware and select one or more <code>VkPhysicalDevice</code>s to use for operations. You can query for properties like VRAM size and device capabilities to select desired devices, for example to prefer using dedicated graphics cards.</p>
<h3><a class="header" href="#step-2---logical-device-and-queue-families" id="step-2---logical-device-and-queue-families">Step 2 - Logical device and queue families</a></h3>
<p>After selecting the right hardware device to use, you need to create a <code>VkDevice</code> (logical device), where you describe more specifically which <code>VkPhysicalDeviceFeatures</code> you will be using, like multi-viewport rendering and 64-bit floats. You also need to specify which queue families you would like to use. Most operations performed with Vulkan, like draw commands and memory operations, are asynchronously executed by submitting them to a <code>VkQueue</code>. Queues are allocated from queue families, where each queue family supports a specific set of operations in its queues. For example, there could be separate queue families for graphics, compute and memory transfer operations. The availability of queue families could also be used as a distinguishing factor in physical device selection. It is possible for a device with Vulkan support to not offer any graphics functionality, however all graphics cards with Vulkan support today will generally support all queue operations that we're interested in.</p>
<h3><a class="header" href="#step-3---window-surface-and-swap-chain" id="step-3---window-surface-and-swap-chain">Step 3 - Window surface and swap chain</a></h3>
<p>Unless you're only interested in offscreen rendering, you will need to create a window to present rendered images to. Windows can be created with the native platform APIs or libraries like <a href="http://www.glfw.org/">GLFW</a>, <a href="https://www.libsdl.org/">SDL</a>, or the <a href="https://github.com/rust-windowing/winit"><code>winit</code></a> crate. We will be using the <code>winit</code> crate in this tutorial, but more about that in the next chapter.</p>
<p>We need two more components to actually render to a window: a window surface (<code>VkSurfaceKHR</code>) and a swap chain (<code>VkSwapchainKHR</code>). Note the <code>KHR</code> postfix, which means that these objects are part of a Vulkan extension. The Vulkan API itself is completely platform agnostic, which is why we need to use the standardized WSI (Window System Interface) extension to interact with the window manager. The surface is a cross-platform abstraction over windows to render to and is generally instantiated by providing a reference to the native window handle, for example <code>HWND</code> on Windows. However, <code>vulkanalia</code> has optional integration with the <code>winit</code> crate which we will be leveraging to handle the platform-specific details of creating a window and associated surface for us.</p>
<p>The swap chain is a collection of render targets. Its basic purpose is to ensure that the image that we're currently rendering to is different from the one that is currently on the screen. This is important to make sure that only complete images are shown. Every time we want to draw a frame we have to ask the swap chain to provide us with an image to render to. When we've finished drawing a frame, the image is returned to the swap chain for it to be presented to the screen at some point. The number of render targets and conditions for presenting finished images to the screen depends on the present mode. Common present modes are  double buffering (vsync) and triple buffering. We'll look into these in the swap chain creation chapter.</p>
<p>Some platforms allow you to render directly to a display without interacting with any window manager through the <code>VK_KHR_display</code> and <code>VK_KHR_display_swapchain</code> extensions. These allow you to create a surface that represents the entire screen and could be used to implement your own window manager, for example.</p>
<h3><a class="header" href="#step-4---image-views-and-framebuffers" id="step-4---image-views-and-framebuffers">Step 4 - Image views and framebuffers</a></h3>
<p>To draw to an image acquired from the swap chain, we have to wrap it into a <code>VkImageView</code> and <code>VkFramebuffer</code>. An image view references a specific part of an image to be used, and a framebuffer references image views that are to be used for color, depth and stencil targets. Because there could be many different images in the swap chain, we'll preemptively create an image view and framebuffer for each of them and select the right one at draw time.</p>
<h3><a class="header" href="#step-5---render-passes" id="step-5---render-passes">Step 5 - Render passes</a></h3>
<p>Render passes in Vulkan describe the type of images that are used during rendering operations, how they will be used, and how their contents should be treated. In our initial triangle rendering application, we'll tell Vulkan that we will use a single image as color target and that we want it to be cleared to a solid color right before the drawing operation. Whereas a render pass only describes the type of images, a <code>VkFramebuffer</code> actually binds specific images to these slots.</p>
<h3><a class="header" href="#step-6---graphics-pipeline" id="step-6---graphics-pipeline">Step 6 - Graphics pipeline</a></h3>
<p>The graphics pipeline in Vulkan is set up by creating a <code>VkPipeline</code> object. It describes the configurable state of the graphics card, like the viewport size and depth buffer operation and the programmable state using <code>VkShaderModule</code> objects. The <code>VkShaderModule</code> objects are created from shader byte code. The driver also needs to know which render targets will be used in the pipeline, which we specify by referencing the render pass.</p>
<p>One of the most distinctive features of Vulkan compared to existing APIs, is that almost all configuration of the graphics pipeline needs to be set in advance. That means that if you want to switch to a different shader or slightly change your vertex layout, then you need to entirely recreate the graphics pipeline. That means that you will have to create many <code>VkPipeline</code> objects in advance for all the different combinations you need for your rendering operations. Only some basic configuration, like viewport size and clear color, can be changed dynamically. All of the state also needs to be described explicitly, there is no default color blend state, for example.</p>
<p>The good news is that because you're doing the equivalent of ahead-of-time compilation versus just-in-time compilation, there are more optimization opportunities for the driver and runtime performance is more predictable, because large state changes like switching to a different graphics pipeline are made very explicit.</p>
<h3><a class="header" href="#step-7---command-pools-and-command-buffers" id="step-7---command-pools-and-command-buffers">Step 7 - Command pools and command buffers</a></h3>
<p>As mentioned earlier, many of the operations in Vulkan that we want to execute, like drawing operations, need to be submitted to a queue. These operations first need to be recorded into a <code>VkCommandBuffer</code> before they can be submitted. These command buffers are allocated from a <code>VkCommandPool</code> that is associated with a specific queue family. To draw a simple triangle, we need to record a command buffer with the following operations:</p>
<ul>
<li>Begin the render pass</li>
<li>Bind the graphics pipeline</li>
<li>Draw 3 vertices</li>
<li>End the render pass</li>
</ul>
<p>Because the image in the framebuffer depends on which specific image the swap chain will give us, we need to record a command buffer for each possible image and select the right one at draw time. The alternative would be to record the command buffer again every frame, which is not as efficient.</p>
<h3><a class="header" href="#step-8---main-loop" id="step-8---main-loop">Step 8 - Main loop</a></h3>
<p>Now that the drawing commands have been wrapped into a command buffer, the main loop is quite straightforward. We first acquire an image from the swap chain with <code>vkAcquireNextImageKHR</code>. We can then select the appropriate command buffer for that image and execute it with <code>vkQueueSubmit</code>. Finally, we return the image to the swap chain for presentation to the screen with <code>vkQueuePresentKHR</code>.</p>
<p>Operations that are submitted to queues are executed asynchronously. Therefore we have to use synchronization objects like semaphores to ensure a correct order of execution. Execution of the draw command buffer must be set up to wait on image acquisition to finish, otherwise it may occur that we start rendering to an image that is still being read for presentation on the screen. The <code>vkQueuePresentKHR</code> call in turn needs to wait for rendering to be finished, for which we'll use a second semaphore that is signaled after rendering completes.</p>
<h3><a class="header" href="#summary" id="summary">Summary</a></h3>
<p>This whirlwind tour should give you a basic understanding of the work ahead for drawing the first triangle. A real-world program contains more steps, like allocating vertex buffers, creating uniform buffers and uploading texture images that will be covered in subsequent chapters, but we'll start simple because Vulkan has enough of a steep learning curve as it is. Note that we'll cheat a bit by initially embedding the vertex coordinates in the vertex shader instead of using a vertex buffer. That's because managing vertex buffers requires some familiarity with command buffers first.</p>
<p>So in short, to draw the first triangle we need to:</p>
<ul>
<li>Create a <code>VkInstance</code></li>
<li>Select a supported graphics card (<code>VkPhysicalDevice</code>)</li>
<li>Create a <code>VkDevice</code> and <code>VkQueue</code> for drawing and presentation</li>
<li>Create a window, window surface and swap chain</li>
<li>Wrap the swap chain images into <code>VkImageView</code></li>
<li>Create a render pass that specifies the render targets and usage</li>
<li>Create framebuffers for the render pass</li>
<li>Set up the graphics pipeline</li>
<li>Allocate and record a command buffer with the draw commands for every possible swap chain image</li>
<li>Draw frames by acquiring images, submitting the right draw command buffer and returning the images back to the swap chain</li>
</ul>
<p>It's a lot of steps, but the purpose of each individual step will be made very simple and clear in the upcoming chapters. If you're confused about the relation of a single step compared to the whole program, you should refer back to this chapter.</p>
<h2><a class="header" href="#api-concepts" id="api-concepts">API concepts</a></h2>
<p>The Vulkan API is defined in terms of the C programming language. This API is defined in the Vulkan API Registry which is <a href="https://github.com/KhronosGroup/Vulkan-Docs/blob/main/xml/vk.xml">an XML file</a> which serves the purpose of being a machine readable definition of the Vulkan API.</p>
<p>The Vulkan <a href="https://github.com/KhronosGroup/Vulkan-Headers">C and C++ headers</a> that are part of the Vulkan SDK you will be installing in the next chapter are generated from this Vulkan API Registry. However, we will not be using these headers, directly or indirectly, because <code>vulkanalia</code> includes a Rust interface to the Vulkan API generated from the Vulkan API registry.</p>
<p>Underneath <code>vulkanalia</code> is the <a href="https://docs.rs/vulkanalia-sys"><code>vulkanalia-sys</code></a> crate which defines the raw types (commands, enums, bitmasks, structs, etc.) defined by the Vulkan API Registry. These raw types are re-exported from the <code>vulkanalia</code> crate in the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/index.html"><code>vk</code></a> module along with some other types generated from the Vulkan API Registry which allow for somewhat simpler and less error-prone usage of the Vulkan API from Rust.</p>
<h3><a class="header" href="#type-names" id="type-names">Type Names</a></h3>
<p>Because Rust has support for namespaces unlike C, the <code>vulkanalia</code> API omits the parts of Vulkan type names that are used for namespacing purposes in C. Types such as structs, unions, and enums lose their <code>Vk</code> prefix (e.g., <code>VkInstance</code> becomes <code>vk::Instance</code> where <code>vk</code> is the the module of the same name in <code>vulkanalia</code>).</p>
<h3><a class="header" href="#enums" id="enums">Enums</a></h3>
<p>Vulkan enums are modeled as structs and the enum values are modeled as associated constants on the struct. Rust enums are not used to model Vulkan enums because use of Rust enums in FFI can lead to <a href="https://github.com/rust-lang/rust/issues/36927">undefined behavior</a>.</p>
<p>Since we don't need to worry about name conflicts between the enum values for different enums (or different libraries), the portions of the enum value names used for namespacing purposes are omitted.</p>
<p>For example, the <code>VK_OBJECT_TYPE_INSTANCE</code> enum value is the <code>INSTANCE</code> value for the <code>VkObjectType</code> enum. In <code>vulkanalia</code>, this enum value becomes <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.ObjectType.html#associatedconstant.INSTANCE"><code>vk::ObjectType::INSTANCE</code></a>.</p>
<h3><a class="header" href="#bitmasks" id="bitmasks">Bitmasks</a></h3>
<p>Vulkan bitmasks are modeled as structs with the bitflags as associated constants (similarly to enums) which are generated by the <code>bitflags!</code> macro from the <a href="https://github.com/bitflags/bitflags"><code>bitflags</code></a> crate.</p>
<p>Like with enums values, the portions of bitmask names used for namespacing purposes are omitted.</p>
<p>For example, the <code>VK_BUFFER_USAGE_TRANSFER_SRC_BIT</code> bitflag is the <code>TRANSFER_SRC</code> bitflag for the <code>VkBufferUsageFlags</code> bitmask. In <code>vulkanalia</code>, this becomes <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.BufferUsageFlags.html#associatedconstant.TRANSFER_SRC"><code>vk::BufferUsageFlags::TRANSFER_SRC</code></a>.</p>
<h3><a class="header" href="#commands" id="commands">Commands</a></h3>
<p>The raw Vulkan commands are defined in <code>vulkanalia</code> with the <code>PFN_</code> (pointer to function) prefix. So <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/type.PFN_vkEnumerateInstanceExtensionProperties.html"><code>vk::PFN_vkEnumerateInstanceExtensionProperties</code></a> refers to a function pointer for the <code>vkEnumerateInstanceExtensionProperties</code> Vulkan command.</p>
<p>If we want to actually call these Vulkan commands, we first need to load them. Vulkan commands are loaded by and stored in four structs, the contents of which are determined by how those commands are loaded. Only two Vulkan commands are directly loaded from a Vulkan shared library, <code>vkGetInstanceProcAddr</code> and <code>vkGetDeviceProcAddr</code>. These commands are then used to load all of the other Vulkan commands. The four structs are (note that Vulkan instances and devices are a topic that will be covered in future chapters):</p>
<ul>
<li><a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.StaticCommands.html"><code>vk::StaticCommands</code></a> – the Vulkan commands listed above which are loaded directly from a Vulkan shared library</li>
<li><a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.EntryCommands.html"><code>vk::EntryCommands</code></a> – the Vulkan commands loaded using <code>vkGetInstanceProcAddr</code> and a null Vulkan instance (i.e., Vulkan commands not tied to a particular Vulkan instance)</li>
<li><a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.InstanceCommands.html"><code>vk::InstanceCommands</code></a> – the Vulkan commands loaded using <code>vkGetInstanceProcAddr</code> and a valid Vulkan instance</li>
<li><a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.DeviceCommands.html"><code>vk::DeviceCommands</code></a> – the Vulkan commands loaded using <code>vkGetDeviceProcAddr</code> and a valid Vulkan device</li>
</ul>
<p>These structs allow you to easily load and call raw Vulkan commands from Rust, but <code>vulkanalia</code> offers wrappers around the raw Vulkan commands which make calling them from Rust easier and less error-prone.</p>
<h3><a class="header" href="#command-wrappers" id="command-wrappers">Command wrappers</a></h3>
<p>An example of a typical Vulkan command signature looks like this in C:</p>
<pre><code class="language-c">VkResult vkEnumerateInstanceExtensionProperties(
    const char* pLayerName,
    uint32_t* pPropertyCount,
    VkExtensionProperties* pProperties
);
</code></pre>
<p>Someone who is familiar with the conventions of the Vulkan API could quickly see how this command is supposed to be used from this signature alone despite it not including some key information.</p>
<p>For those new to the Vulkan API, a look at the <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkEnumerateDeviceExtensionProperties.html">documentation</a> for this command will be more illuminating. The description of the behavior of this command in the documentation suggests that using this command to list the available extensions will be a multi-step process:</p>
<ol>
<li>Call the command to get the number of extensions</li>
<li>Allocate a buffer that can contain the specified number of extensions</li>
<li>Call the command again to populate the buffer with the extensions</li>
</ol>
<p>So in C++, this might look like this (ignoring the result of the command for simplicity):</p>
<pre><code class="language-c++">// 1.
uint32_t pPropertyCount;
vkEnumerateInstanceExtensionProperties(NULL, &amp;pPropertyCount, NULL);

// 2.
std::vector&lt;VkExtensionProperties&gt; pProperties{pPropertyCount};

// 3.
vkEnumerateInstanceExtensionProperties(NULL, &amp;pPropertyCount, pProperties.data());
</code></pre>
<p>The Rust signature for the command wrapper looks like this:</p>
<pre><code class="language-rust noplaypen">fn enumerate_instance_extension_properties(
    &amp;self,
    layer_name: Option&lt;&amp;[u8]&gt;,
) -&gt; VkResult&lt;Vec&lt;ExtensionProperties&gt;&gt;;
</code></pre>
<p>These command wrappers simplify usage of Vulkan commands by handling the need to call some commands twice such as in this case as well as capturing the fallibility of the underlying command by returning a (Rust) <code>Result</code> (<a href="https://docs.rs/vulkanalia/latest/vulkanalia/type.VkResult.html"><code>VkResult&lt;T&gt;</code></a> in this case is a type alias for <code>Result&lt;T, vk::Result&gt;</code>). Note that the <code>layer_name</code> argument is optional, a fact which is defined by the Vulkan API Registry but cannot be indicated by a C function signature alone.</p>
<p>You likely noticed the <code>&amp;self</code> parameter in the above command wrapper. These command wrappers are defined in traits which are implemented for types exposed by <code>vulkanalia</code>. The traits can be separated into two categories: version traits and extension traits. The version traits offer command wrappers for the commands which are a standard part of Vulkan whereas the extension traits offer command wrappers for the commands which are defined as part of Vulkan extensions.</p>
<p>For example, the above command wrapper is in the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.EntryV1_0.html"><code>vk::EntryV1_0</code></a> trait since it is a standard Vulkan command that is part of Vulkan 1.0 and is not dependent on a valid Vulkan instance or version (as described in the previous section).</p>
<p>A Vulkan device command that was added in Vulkan 1.2 would be in the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.DeviceV1_2.html"><code>vk::DeviceV1_2</code></a> trait. <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.KhrSurfaceExtension.html"><code>vk::KhrSurfaceExtension</code></a> is an example of an extension trait that we will be using in future chapters to call Vulkan commands that are defined as part of the <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_KHR_surface.html"><code>VK_KHR_surface</code></a> extension.</p>
<p>These traits are defined for types which contain both the loaded commands and the required Vulkan instance or device (if any). These types have been lovingly hand-crafted and are not part of the generated Vulkan bindings in the <code>vk</code> module of <code>vulkanalia</code>. They will be used in future chapters and are the <code>Entry</code>, <code>Instance</code>, and <code>Device</code> structs and can be found in the <code>Structs</code> section of the <a href="https://docs.rs/vulkanalia"><code>vulkanalia</code> documentation</a>.</p>
<h3><a class="header" href="#builders" id="builders">Builders</a></h3>
<p>The Vulkan API heavily utilizes structs as parameters for Vulkan commands. Many of these structs have a field which indicates the type of the struct. In the C API (called from C++ in this example), this field (<code>sType</code>) would need to be set explicitly, for example:</p>
<pre><code class="language-c++">std::vector&lt;const char*&gt; extensions{/* 3 extension names */};

VkInstanceCreateInfo info;
info.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
info.enabledExtensionCount = static_cast&lt;uint32_t&gt;(extensions.size());
info.ppEnabledExtensionNames = extensions.data();

VkInstance instance;
vkCreateInstance(&amp;info, NULL, &amp;instance);
</code></pre>
<p><code>vulkanalia</code> retains this approach but makes it a bit easier to work with while also preventing certain classes of errors. <code>vulkanalia</code> has builder structs which simplify the construction of Vulkan structs by populating the struct with defaults which will include the appropriate value for structure type field when present. These builder structs also simplify the setting of linked fields that represent arrays such as <code>enabledExtensionCount</code> and <code>ppEnabledExtensionNames</code> in the above code. Using <code>vulkanalia</code> the above code would become:</p>
<pre><code class="language-rust noplaypen">let extensions = &amp;[/* 3 extensions */];

let info = vk::InstanceCreateInfo::builder()
    .enabled_extension_names(extensions)
    .build();

let instance = entry.create_instance(&amp;info, None).unwrap();
</code></pre>
<p>Here we create a builder struct instance (<a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.InstanceCreateInfoBuilder.html"><code>vk::InstanceCreateInfoBuilder</code></a>) for the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.InstanceCreateInfo.html"><code>vk::InstanceCreateInfo</code></a> struct that will be initially be populated with default values which includes setting the <code>s_type</code> field to <code>vk::StructureType::INSTANCE_CREATE_INFO</code>. Then we set the enabled extension names (which will set both the <code>enabled_extension_count</code> and <code>enabled_extension_name</code> fields). Then we can build our <code>vk::InstanceCreateInfo</code> struct and pass it to the Vulkan command wrapper.</p>
<p>However, the above Rust code involves a certain degree of danger. The builder structs have lifetimes which enforce that the references stored in them live at least as long as the struct. In the above example, this means that the Rust compiler will make sure that the value passed to the <code>enabled_extension_names</code> method lives at least as long as the builder struct. However, as soon as we call <code>build()</code> to get the raw Vulkan struct these lifetimes are discarded which means the Rust compiler can't prevent us from attempting to access a value that has been dropped.</p>
<p>The following code will (hopefully) crash since the temporary <code>Vec</code> passed to the <code>enabled_extension_names</code> value will have been dropped by the time we call the Vulkan command with our <code>vk::InstanceCreateInfo</code> struct:</p>
<pre><code class="language-rust noplaypen">let info = vk::InstanceCreateInfo::builder()
    .enabled_extension_names(&amp;vec![/* 3 extensions */])
    .build();

let instance = entry.create_instance(&amp;info, None).unwrap();
</code></pre>
<p>Fortunately, <code>vulkanalia</code> has a solution for this. Simply don't call <code>build()</code> and instead pass the builder struct to the command wrapper instead! Anywhere a Vulkan struct is expected in a command wrapper you can instead provide the associated builder struct. If you remove the <code>build()</code> call from the above code the Rust compiler will be able to use the lifetimes on the builder struct to reject this incorrect code with <code>error[E0716]: temporary value dropped while borrowed</code>.</p>
<h3><a class="header" href="#preludes" id="preludes">Preludes</a></h3>
<p><code>vulkanalia</code> offers <a href="https://docs.rs/vulkanalia/latest/vulkanalia/prelude/index.html">prelude modules</a> that expose the basic types needed to use the crate. One prelude module is available per Vulkan version and each will expose the relevant command traits along with other very frequently used types:</p>
<pre><code class="language-rust noplaypen">// Vulkan 1.0
use vulkanalia::prelude::v1_0::*;

// Vulkan 1.1
use vulkanalia::prelude::v1_1::*;

// Vulkan 1.2
use vulkanalia::prelude::v1_2::*;
</code></pre>
<h2><a class="header" href="#validation-layers" id="validation-layers">Validation layers</a></h2>
<p>As mentioned earlier, Vulkan is designed for high performance and low driver overhead. Therefore it will include very limited error checking and debugging capabilities by default. The driver will often crash instead of returning an error code if you do something wrong, or worse, it will appear to work on your graphics card and completely fail on others.</p>
<p>Vulkan allows you to enable extensive checks through a feature known as <em>validation layers</em>. Validation layers are pieces of code that can be inserted between the API and the graphics driver to do things like running extra checks on function parameters and tracking memory management problems. The nice thing is that you can enable them during development and then completely disable them when releasing your application for zero overhead. Anyone can write their own validation layers, but the Vulkan SDK by LunarG provides a standard set of validation layers that we'll be using in this tutorial. You also need to register a callback function to receive debug messages from the layers.</p>
<p>Because Vulkan is so explicit about every operation and the validation layers are so extensive, it can actually be a lot easier to find out why your screen is black compared to OpenGL and Direct3D!</p>
<h1><a class="header" href="#development-environment" id="development-environment">Development environment</a></h1>
<p>In this chapter we'll set up your environment for developing Vulkan applications by installing the Vulkan SDK for your operating system. This tutorial assumes you already have a working Rust (1.47+) development environment.</p>
<h2><a class="header" href="#cargo-project" id="cargo-project">Cargo project</a></h2>
<p>First let's create our Cargo project:</p>
<p><code>cargo new vulkan-tutorial</code></p>
<p>After this command has executed, you'll have a folder called <code>vulkan-tutorial</code> containing a minimal Cargo project which produces a Rust executable.</p>
<p>Open the <code>Cargo.toml</code> file in the folder and add these dependencies in the pre-existing <code>[dependencies]</code> section:</p>
<pre><code class="language-toml">anyhow = &quot;1&quot;
lazy_static = &quot;1&quot;
log = &quot;0.4&quot;
nalgebra-glm = &quot;0.3&quot;
png = &quot;0.16&quot;
pretty_env_logger = &quot;0.4&quot;
tobj = &quot;2&quot;
vulkanalia = { version = &quot;*&quot;, features = [&quot;libloading_&quot;, &quot;winit_&quot;] }
winit = &quot;0.23&quot;
</code></pre>
<ul>
<li><code>anyhow</code> – used for simple error handling</li>
<li><code>lazy_static</code> – used to store static data like vertices</li>
<li><code>log</code> – used for logging statements</li>
<li><code>nalgebra-glm</code> – used as a Rust replacement for <a href="https://glm.g-truc.net">GLM</a> (graphics math library)</li>
<li><code>png</code> – used to load PNGs to use as textures</li>
<li><code>pretty_env_logger</code> – used to print our logs to the console</li>
<li><code>tobj</code> – used to load 3D models in the <a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront .obj format</a></li>
<li><code>vulkanalia</code> – used to call the Vulkan API</li>
<li><code>winit</code> – used to create a window to render to</li>
</ul>
<h2><a class="header" href="#vulkan-sdk" id="vulkan-sdk">Vulkan SDK</a></h2>
<p>The most important component you'll need for developing Vulkan applications is the SDK. It includes the headers, standard validation layers, debugging tools and a loader for the Vulkan functions. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.</p>
<h3><a class="header" href="#windows" id="windows">Windows</a></h3>
<p>The SDK can be downloaded from the <a href="https://vulkan.lunarg.com/">LunarG website</a> using the buttons at the bottom of the page. You don't have to create an account, but it will give you access to some additional documentation that may be useful to you.</p>
<p><img src="./images/vulkan_sdk_download_buttons.png" alt="" /></p>
<p>Proceed through the installation and pay attention to the install location of the SDK. The first thing we'll do is verify that your graphics card and driver properly support Vulkan. Go to the directory where you installed the SDK, open the <code>Bin</code> directory and run the <code>vkcube.exe</code> demo. You should see the following:</p>
<p><img src="./images/cube_demo.png" alt="" /></p>
<p>If you receive an error message then ensure that your drivers are up-to-date, include the Vulkan runtime and that your graphics card is supported. See the <a href="introduction.html">introduction chapter</a> for links to drivers from the major vendors.</p>
<p>There is another program in this directory that will be useful for development. The <code>glslangValidator.exe</code> and <code>glslc.exe</code> programs will be used to compile shaders from the human-readable <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a> to bytecode. We'll cover this in depth in the <a href="pipeline/shader_modules.html">shader modules chapter</a>. The <code>Bin</code> directory also contains the binaries of the Vulkan loader and the validation layers, while the <code>Lib</code> directory contains the libraries.</p>
<p>Feel free to explore the other files, but we won't need them for this tutorial.</p>
<h3><a class="header" href="#linux" id="linux">Linux</a></h3>
<p>These instructions will be aimed at Ubuntu users, but you may be able to follow along by changing the <code>apt</code> commands to the package manager commands that are appropriate for you.</p>
<p>The most important components you'll need for developing Vulkan applications on Linux are the Vulkan loader, validation layers, and a couple of command-line utilities to test whether your machine is Vulkan-capable:</p>
<ul>
<li><code>sudo apt install vulkan-tools</code>: Command-line utilities, most importantly <code>vulkaninfo</code> and <code>vkcube</code>. Run these to confirm your machine supports Vulkan.</li>
<li><code>sudo apt install libvulkan-dev</code>: Installs Vulkan loader. The loader looks up the functions in the driver at runtime, similarly to GLEW for OpenGL - if you're familiar with that.</li>
<li><code>sudo apt install vulkan-validationlayers-dev</code>: Installs the standard validation layers. These are crucial when debugging Vulkan applications, and we'll discuss them in the upcoming chapter.</li>
</ul>
<p>If installation was successful, you should be all set with the Vulkan portion. Remember to run <code>vkcube</code> and ensure you see the following pop up in a window:</p>
<p><img src="./images/cube_demo_nowindow.png" alt="" /></p>
<p>If you receive an error message then ensure that your drivers are up-to-date, include the Vulkan runtime and that your graphics card is supported. See the <a href="introduction.html">introduction chapter</a> for links to drivers from the major vendors.</p>
<h3><a class="header" href="#macos" id="macos">macOS</a></h3>
<p>These instructions will assume you are using the <a href="https://brew.sh/">Homebrew package manager</a>. Also, keep in mind that you will need at least MacOS version 10.11, and your device needs to support the <a href="https://en.wikipedia.org/wiki/Metal_(API)#Supported_GPUs">Metal API</a>.</p>
<p>The SDK can be downloaded from the <a href="https://vulkan.lunarg.com/">LunarG website</a> using the buttons at the bottom of the page. You don't have to create an account, but it will give you access to some additional documentation that may be useful to you.</p>
<p><img src="./images/vulkan_sdk_download_buttons.png" alt="" /></p>
<p>The SDK version for MacOS internally uses <a href="https://moltengl.com/">MoltenVK</a>. There is no native support for Vulkan on MacOS, so what MoltenVK does is actually act as a layer that translates Vulkan API calls to Apple's Metal graphics framework. With this you can take advantage of debugging and performance benefits of Apple's Metal framework.</p>
<p>After downloading it, simply extract the contents to a folder of your choice. Inside the extracted folder, in the <code>Applications</code> folder you should have some executable files that will run a few demos using the SDK. Run the <code>vkcube</code> executable and you will see the following:</p>
<p><img src="./images/cube_demo_mac.png" alt="" /></p>
<h1><a class="header" href="#faq" id="faq">FAQ</a></h1>
<p>This page lists solutions to common problems that you may encounter while developing Vulkan applications.</p>
<ul>
<li>
<p><strong>I get an access violation error in the core validation layer</strong>: Make sure that MSI Afterburner / RivaTuner Statistics Server is not running, because it has some compatibility problems with Vulkan.</p>
</li>
<li>
<p><strong>I don't see any messages from the validation layers / Validation layers are not available</strong>: First make sure that the validation layers get a chance to print errors by keeping the terminal open after your program exits. You can do this from Visual Studio by running your program with Ctrl-F5 instead of F5, and on Linux by executing your program from a terminal window. If there are still no messages and you are sure that validation layers are turned on, then you should ensure that your Vulkan SDK is correctly installed by following the &quot;Verify the Installation&quot; instructions <a href="https://vulkan.lunarg.com/doc/view/1.2.135.0/windows/getting_started.html">on this page</a>. Also ensure that your SDK version is at least 1.1.106.0 to support the <code>VK_LAYER_KHRONOS_validation</code> layer.</p>
</li>
<li>
<p><strong>vkCreateSwapchainKHR triggers an error in SteamOverlayVulkanLayer64.dll</strong>: This appears to be a compatibility problem in the Steam client beta. There are a few possible workarounds:</p>
<ul>
<li>Opt out of the Steam beta program.</li>
<li>Set the <code>DISABLE_VK_LAYER_VALVE_steam_overlay_1</code> environment variable to <code>1</code></li>
<li>Delete the Steam overlay Vulkan layer entry in the registry under <code>HKEY_LOCAL_MACHINE\SOFTWARE\Khronos\Vulkan\ImplicitLayers</code></li>
</ul>
</li>
</ul>
<p>Example:</p>
<p><img src="./images/steam_layers_env.png" alt="" /></p>
<h1><a class="header" href="#base-code" id="base-code">Base code</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/00_base_code.rs">main.rs</a></p>
<p>In the <code>Development environment</code> chapter we created a Cargo project and added the necessary dependencies. In this chapter we will be replacing the code in the <code>src/main.rs</code> file with the following code:</p>
<pre><pre class="playground"><code class="language-rust">use anyhow::*;
use winit::dpi::LogicalSize;
use winit::event::{Event, WindowEvent};
use winit::event_loop::{ControlFlow, EventLoop};
use winit::window::{Window, WindowBuilder};

fn main() -&gt; Result&lt;()&gt; {
    pretty_env_logger::init();
    info!(&quot;Starting program...&quot;);

    // Window

    let event_loop = EventLoop::new();
    let window = WindowBuilder::new()
        .with_title(&quot;Vulkan Tutorial (Rust)&quot;)
        .with_inner_size(LogicalSize::new(1024, 768))
        .build(&amp;event_loop)?;

    // App

    let mut app = App::create(&amp;window)?;
    let mut destroying = false;
    event_loop.run(move |event, _, control_flow| {
        *control_flow = ControlFlow::Poll;
        match event {
            // Render a frame if our Vulkan app is not being destroyed.
            Event::MainEventsCleared if !destroying =&gt; app.render(&amp;window).unwrap(),
            // Destroy our Vulkan app.
            Event::WindowEvent { event: WindowEvent::CloseRequested, .. } =&gt; {
                destroying = true;
                *control_flow = ControlFlow::Exit;
                app.destroy();
            }
            _ =&gt; {}
        }
    });
}

/// Our Vulkan app.
#[derive(Clone, Debug)]
struct App {}

impl App {
    /// Creates our Vulkan app.
    fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        Ok(Self {})
    }

    /// Renders a frame for our Vulkan app.
    fn render(&amp;mut self, window: &amp;Window) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    /// Destroys our Vulkan app.
    fn destroy(&amp;mut self) {}
}

/// The Vulkan handles and associated properties used by our Vulkan app.
#[derive(Clone, Debug, Default)]
struct AppData {}
</code></pre></pre>
<p>We first import <code>anyhow::Result</code> which will be used to easily represent all of the results in our program. Next we import all of the <code>winit</code> types we need to create a window and start an event loop for that window.</p>
<p>Next comes our <code>main</code> function (which returns the imported <code>anyhow::Result</code> type). This function starts by initializing <code>pretty_env_logger</code> which will print our logs to the console (as shown later).</p>
<p>Then we create an event loop and window to render to using <code>winit</code> using <code>LogicalSize</code> which will scale the window according to the DPI of your display. If you want to know more about UI scaling you can read the <a href="https://docs.rs/winit/latest/winit/dpi/index.html">relevant <code>winit</code> documentation</a>.</p>
<p>Next we create an instance of our Vulkan app (<code>App</code>) and enter into our rendering loop. This loop will continually render our scene to the window until you request the window to be closed at which point the app will be destroyed and the program will exit. The <code>destroying</code> flag is necessary to not keep attempting to render the scene while the app is being destroyed which would most likely result in the program crashing after attempting to access Vulkan resources that have been destroyed.</p>
<p>Lastly comes <code>App</code> and <code>AppData</code>. <code>App</code> will be used to implement the setup, rendering, and destruction logic required for the Vulkan program we will be building over the course of the following chapters. <code>AppData</code> will serve simply as a container for the large number of Vulkan resources we will need to create and initialize which will allow for them to be easily passed to functions to be read and/or modified.</p>
<p>This will come in handy because many of the following chapters consist of adding a function which takes a <code>&amp;mut AppData</code> and creates and initializes Vulkan resources. These functions will then be called from our <code>App::create</code> constructor method to set up our Vulkan app. Then, before our program exits, these Vulkan resources will be released by our <code>App::destroy</code> method.</p>
<h2><a class="header" href="#resource-management" id="resource-management">Resource management</a></h2>
<p>Just like each chunk of memory allocated in C with <code>malloc</code> requires a corresponding call to <code>free</code>, every Vulkan object that we create needs to be explicitly destroyed when we no longer need it. In Rust it is possible to perform automatic resource management using <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a> possibly combined with smart pointers like <code>Rc</code> or <code>Arc</code>. However, the author of <a href="https://vulkan-tutorial.com">https://vulkan-tutorial.com</a> chose to be explicit about allocation and deallocation of Vulkan objects in this tutorial and I have decided to take the same approach. After all, Vulkan's niche is to be explicit about every operation to avoid mistakes, so it's good to be explicit about the lifetime of objects to learn how the API works.</p>
<p>After following this tutorial, you could implement automatic resource management by writing Rust structs that wrap Vulkan objects and release them in their <code>Drop</code> implementation. RAII is the recommended model for larger Vulkan programs, but for learning purposes it's always good to know what's going on behind the scenes.</p>
<p>Vulkan objects are either created directly with commands like <code>vkCreateXXX</code>, or allocated through another object with commands like <code>vkAllocateXXX</code>. After making sure that an object is no longer used anywhere, you need to destroy it with the counterparts <code>vkDestroyXXX</code> and <code>vkFreeXXX</code>. The parameters for these commands generally vary for different types of objects, but there is one parameter that they all share: <code>pAllocator</code>. This is an optional parameter that allows you to specify callbacks for a custom memory allocator. We will ignore this parameter in the tutorial and always pass <code>None</code> as argument.</p>
<h1><a class="header" href="#instance" id="instance">Instance</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/01_instance_creation.rs">main.rs</a></p>
<p>The very first thing you will want to do is initialize the Vulkan library by creating an <em>instance</em>. The instance is the connection between your application and the Vulkan library and creating it involves specifying some details about your application to the driver. To get started, add the following imports:</p>
<pre><code class="language-rust noplaypen">use vulkanalia::loader::{LibloadingLoader, LIBRARY};
use vulkanalia::winit as vk_winit;
use vulkanalia::prelude::v1_0::*;
</code></pre>
<p>Here we first import <code>LibloadingLoader</code> which serves as <code>vulkanalia</code>'s <code>libloading</code> integration which we will use to load the initial Vulkan commands from the Vulkan shared library. The standard name of the Vulkan shared library on your operating system (e.g., <code>vulkan-1.dll</code> on Windows) is then imported as <code>LIBRARY</code>.</p>
<p>Next we import <code>vulkanalia</code>'s <code>winit</code> integration as <code>vk_winit</code> which in this chapter we will use to enumerate the global Vulkan extensions required to render to a <code>winit</code> window. In a future chapter we will also use <code>vk_winit</code> to link our Vulkan instance with our window.</p>
<p>Lastly we import the Vulkan 1.0 prelude from <code>vulkanalia</code> which will provide all of the other Vulkan-related imports we will need for this and future chapters.</p>
<p>Now, to create an instance we'll next have to fill in a struct with some information about our application. This data is technically optional, but it may provide some useful information to the driver in order to optimize our specific application (e.g., because it uses a well-known graphics engine with certain special behavior). This struct is called <code>vk::ApplicationInfo</code> and we'll create it in a new function called <code>create_instance</code> that takes a Vulkan entry point (which we will create later) and returns a Vulkan instance:</p>
<pre><code class="language-rust noplaypen">fn create_instance(entry: &amp;Entry) -&gt; Result&lt;Instance&gt; {
    let application_info = vk::ApplicationInfo::builder()
        .application_name(b&quot;Vulkan Tutorial\0&quot;)
        .application_version(vk::make_version(1, 0, 0))
        .engine_name(b&quot;No Engine\0&quot;)
        .engine_version(vk::make_version(1, 0, 0))
        .api_version(vk::make_version(1, 0, 0));
}
</code></pre>
<p>A lot of information in Vulkan is passed through structs instead of function parameters and we'll have to fill in one more struct to provide sufficient information for creating an instance. This next struct is not optional and tells the Vulkan driver which global extensions and validation layers we want to use. Global here means that they apply to the entire program and not a specific device, which will become clear in the next few chapters. First we'll need to use <code>vulkanalia</code>'s <code>winit</code> integration to enumerate the required global extensions and convert them into null-terminated C strings (<code>*const c_char</code>):</p>
<pre><code class="language-rust noplaypen">let extensions = vk_winit::get_required_instance_extensions(entry)?
    .iter()
    .map(|e| e.to_cstr().as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<p>With our list of required global extensions in hand we can create and return a Vulkan instance using the Vulkan entry point passed into this function:</p>
<pre><code class="language-rust noplaypen">let info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_extension_names(&amp;extensions);

Ok(entry.create_instance(&amp;info, None)?)
</code></pre>
<p>As you'll see, the general pattern that object creation function parameters in Vulkan follow is:</p>
<ul>
<li>Reference to struct with creation info</li>
<li>Optional reference to custom allocator callbacks, always <code>None</code> in this tutorial</li>
</ul>
<p>Now that we have a function to create Vulkan instances from entry points, we next need to create a Vulkan entry point. This entry point will load the Vulkan commands used to query instance support and create instances. But before we do that, let's add some fields to our <code>App</code> struct to store the Vulkan entry point and instance we will be creating:</p>
<pre><code class="language-rust noplaypen">struct App {
    entry: Entry,
    instance: Instance,
}
</code></pre>
<p>To populate these fields, update the <code>App::create</code> method to the following:</p>
<pre><code class="language-rust noplaypen">fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
    let loader = LibloadingLoader::new(LIBRARY)?;
    let entry = Entry::new(loader).map_err(|b| anyhow!(&quot;{}&quot;, b))?;

    let instance = create_instance(&amp;entry)?;

    Ok(Self { entry, instance })
}
</code></pre>
<p>Here we first create a Vulkan function loader which will be used to load the initial Vulkan commands from the Vulkan shared library. Next we create the Vulkan entry point using the function loader which will load all of the commands we need to manage Vulkan instances. Lastly we are now able to call our <code>create_instance</code> function with the Vulkan entry point.</p>
<h2><a class="header" href="#cleaning-up" id="cleaning-up">Cleaning up</a></h2>
<p>The <code>Instance</code> should only be destroyed right before the program exits. It can be destroyed in the <code>App::destroy</code> method using the <code>destroy_instance</code> command wrapper:</p>
<pre><code class="language-rust noplaypen">fn destroy(&amp;mut self) {
    self.instance.destroy_instance(None);
}
</code></pre>
<p>Like the Vulkan commands used to create objects, the commands used to destroy objects also take an optional reference to custom allocator callbacks. So like before, we pass <code>None</code> to indicate we are content with the default allocation behavior.</p>
<h2><a class="header" href="#instance-vs-vkinstance" id="instance-vs-vkinstance"><code>Instance</code> vs <code>vk::Instance</code></a></h2>
<p>When we call <code>create_instance</code>, what we get back is not a raw Vulkan instance as would be returned by the Vulkan command <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkCreateInstance.html"><code>vkCreateInstance</code></a>. Instead what we got back is a custom type defined by <code>vulkanalia</code> which combines both a raw Vulkan instance and the commands loaded for that specific instance.</p>
<p>This is the <code>Instance</code> type we have been using (imported from the <code>vulkanalia</code> prelude) which should not be confused with the <code>vk::Instance</code> type which represents a raw Vulkan instance. In future chapters we will also use the <code>Device</code> type which, like <code>Instance</code>, is a pairing of a raw Vulkan device (<code>vk::Device</code>) and the commands loaded for that specific device. Fortunately we will not be using <code>vk::Instance</code> or <code>vk::Device</code> directly so you won't need to worry about getting them mixed up.</p>
<p>Because an <code>Instance</code> contains both a Vulkan instance and the associated commands, the command wrappers like <code>destroy_instance</code> implemented for an <code>Instance</code> are able to provide the Vulkan instance when it is required by the underlying Vulkan command.</p>
<p>If you look at the documentation for the <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/vkDestroyInstance.html"><code>vkDestroyInstance</code></a> command, you will see that it takes two parameters: the instance to destroy and the optional custom allocator callbacks. However, <code>destroy_instance</code> only takes the optional custom allocator callbacks because it is able to provide the raw Vulkan handle as the first parameter itself as described above.</p>
<p>Before continuing with the more complex steps after instance creation, it's time to evaluate our debugging options by checking out validation layers.</p>
<h1><a class="header" href="#validation-layers-1" id="validation-layers-1">Validation layers</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/02_validation_layers.rs">main.rs</a></p>
<p>The Vulkan API is designed around the idea of minimal driver overhead and one of the manifestations of that goal is that there is very limited error checking in the API by default. Even mistakes as simple as setting enumerations to incorrect values are generally not explicitly handled and will simply result in crashes or undefined behavior. Because Vulkan requires you to be very explicit about everything you're doing, it's easy to make many small mistakes like using a new GPU feature and forgetting to request it at logical device creation time.</p>
<p>However, that doesn't mean that these checks can't be added to the API. Vulkan introduces an elegant system for this known as validation layers. Validation layers are optional components that hook into Vulkan function calls to apply additional operations. Common operations in validation layers are:</p>
<ul>
<li>Checking the values of parameters against the specification to detect misuse</li>
<li>Tracking creation and destruction of objects to find resource leaks</li>
<li>Checking thread safety by tracking the threads that calls originate from</li>
<li>Logging every call and its parameters to the standard output</li>
<li>Tracing Vulkan calls for profiling and replaying</li>
</ul>
<p>Here's an example of what the implementation of a function in a diagnostics validation layer could look like (in C):</p>
<pre><code class="language-c">VkResult vkCreateInstance(
    const VkInstanceCreateInfo* pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
    VkInstance* instance
) {
    if (pCreateInfo == nullptr || instance == nullptr) {
        log(&quot;Null pointer passed to required parameter!&quot;);
        return VK_ERROR_INITIALIZATION_FAILED;
    }

    return real_vkCreateInstance(pCreateInfo, pAllocator, instance);
}
</code></pre>
<p>These validation layers can be freely stacked to include all the debugging functionality that you're interested in. You can simply enable validation layers for debug builds and completely disable them for release builds, which gives you the best of both worlds!</p>
<p>Vulkan does not come with any validation layers built-in, but the LunarG Vulkan SDK provides a nice set of layers that check for common errors. They're also completely <a href="https://github.com/KhronosGroup/Vulkan-ValidationLayers">open source</a>, so you can check which kind of mistakes they check for and contribute. Using the validation layers is the best way to avoid your application breaking on different drivers by accidentally relying on undefined behavior.</p>
<p>Validation layers can only be used if they have been installed onto the system. For example, the LunarG validation layers are only available on PCs with the Vulkan SDK installed.</p>
<p>There were formerly two different types of validation layers in Vulkan: instance and device specific. The idea was that instance layers would only check calls related to global Vulkan objects like instances, and device specific layers would only check calls related to a specific GPU. Device specific layers have now been deprecated, which means that instance validation layers apply to all Vulkan calls. The specification document still recommends that you enable validation layers at device level as well for compatibility, which is required by some implementations. We'll simply specify the same layers as the instance at logical device level, which we'll see later on.</p>
<p>Before we get started, we'll need some new imports for this chapter:</p>
<pre><code class="language-rust noplaypen">use std::collections::HashSet;
use std::ffi::CStr;
use std::os::raw::c_void;

use log::*;
</code></pre>
<p><code>HashSet</code> will be used for storing and querying supported layers and the other imports will be used in the function we will be writing to log messages from the validation layer.</p>
<h2><a class="header" href="#using-validation-layers" id="using-validation-layers">Using validation layers</a></h2>
<p>In this section we'll see how to enable the standard diagnostics layers provided by the Vulkan SDK. Just like extensions, validation layers need to be enabled by specifying their name. All of the useful standard validation is bundled into a layer included in the SDK that is known as <code>VK_LAYER_KHRONOS_validation</code>.</p>
<p>Let's first add two configuration variables to the program to specify the layers to enable and whether to enable them or not. I've chosen to base that value on whether the program is being compiled in debug mode or not.</p>
<pre><code class="language-rust noplaypen">const VALIDATION_ENABLED: bool =
    cfg!(debug_assertions);

const VALIDATION_LAYER: vk::ExtensionName =
    vk::to_extension_name(b&quot;VK_LAYER_KHRONOS_validation\0&quot;);
</code></pre>
<p>We'll add some new code to our <code>create_instance</code> function that collects the supported instance layers into a <code>HashSet</code>, checks that the validation layer is available, and creates a list of layer names containing the validation layer. This code should go right below where the <code>vk::ApplicationInfo</code> struct is built:</p>
<pre><code class="language-rust noplaypen">let available_layers = entry
    .enumerate_instance_layer_properties()?
    .iter()
    .map(|l| l.layer_name)
    .collect::&lt;HashSet&lt;_&gt;&gt;();

if VALIDATION_ENABLED &amp;&amp; !available_layers.contains(&amp;VALIDATION_LAYER) {
    return Err(anyhow!(&quot;Validation layer requested but not supported.&quot;));
}

let layers = if VALIDATION_ENABLED {
    vec![VALIDATION_LAYER.to_cstr().as_ptr()]
} else {
    Vec::new()
};
</code></pre>
<p>Then you'll need to specify the requested layers in <code>vk::CreateInstanceInfo</code> by adding a call to the <code>enabled_layer_names</code> builder method:</p>
<pre><code class="language-rust noplaypen">let info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions);
</code></pre>
<p>Now run the program in debug mode and ensure that the <code>Validation layer requested but not supported.</code> error does not occur. If it does, then have a look at the FAQ. If you get past that check, then <code>entry.create_instance(...)</code> should never return a <code>vk::Result::ERROR_LAYER_NOT_PRESENT</code> error but you should still run the program to be sure.</p>
<h2><a class="header" href="#message-callback" id="message-callback">Message callback</a></h2>
<p>The validation layers will print debug messages to the standard output by default, but we can also handle them ourselves by providing an explicit callback in our program. This will also allow you to decide which kind of messages you would like to see, because not all are necessarily (fatal) errors. If you don't want to do that right now then you may skip to the last section in this chapter.</p>
<p>To set up a callback in the program to handle messages and the associated details, we have to set up a debug messenger with a callback using the <code>VK_EXT_debug_utils</code> extension.</p>
<p>We'll add some more code to our <code>create_instance</code> function. This time we'll modify the <code>extensions</code> list to be mutable and then add the debug utilities extension to the list when the validation layer is enabled:</p>
<pre><code class="language-rust noplaypen">let mut extensions = vk_winit::get_required_instance_extensions(entry)?
    .iter()
    .map(|e| e.to_cstr().as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();

if VALIDATION_ENABLED {
    extensions.push(vk::EXT_DEBUG_UTILS_EXTENSION.to_cstr().as_ptr());
}
</code></pre>
<p>Run the program to make sure you don't receive a <code>vk::Result::ERROR_EXTENSION_NOT_PRESENT</code> error. We don't really need to check for the existence of this extension, because it should be implied by the availability of the validation layers.</p>
<p>Now let's see what a debug callback function looks like. Add a new <code>extern &quot;system&quot;</code> function called <code>debugCallback</code> with the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/type.PFN_vkDebugUtilsMessengerCallbackEXT.html"><code>PFN_vkDebugUtilsMessengerCallbackEXT</code></a> prototype. The <code>extern &quot;system&quot;</code> is necessary to support Vulkan calling it from C.</p>
<pre><code class="language-rust noplaypen">extern &quot;system&quot; fn debug_callback(
    severity: vk::DebugUtilsMessageSeverityFlagsEXT,
    type_: vk::DebugUtilsMessageTypeFlagsEXT,
    data: *const vk::DebugUtilsMessengerCallbackDataEXT,
    _: *mut c_void,
) -&gt; vk::Bool32 {
    let data = unsafe { *data };
    let message = unsafe { CStr::from_ptr(data.message) }.to_string_lossy();

    if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::ERROR {
        error!(&quot;({:?}) {}&quot;, type_, message);
    } else if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::WARNING {
        warn!(&quot;({:?}) {}&quot;, type_, message);
    } else if severity &gt;= vk::DebugUtilsMessageSeverityFlagsEXT::INFO {
        debug!(&quot;({:?}) {}&quot;, type_, message);
    } else {
        trace!(&quot;({:?}) {}&quot;, type_, message);
    }

    vk::FALSE
}
</code></pre>
<p>The first parameter specifies the severity of the message, which is one of the following flags:</p>
<ul>
<li><code>vk::DebugUtilsMessageSeverityFlagsEXT::VERBOSE</code>: Diagnostic message</li>
<li><code>vk::DebugUtilsMessageSeverityFlagsEXT::INFO</code>: Informational message like the creation of a resource</li>
<li><code>vk::DebugUtilsMessageSeverityFlagsEXT::WARNING</code>: Message about behavior that is not necessarily an error, but very likely a bug in your application</li>
<li><code>vk::DebugUtilsMessageSeverityFlagsEXT::ERROR</code>: Message about behavior that is invalid and may cause crashes</li>
</ul>
<p>The values of this enumeration are set up in such a way that you can use a comparison operation to check if a message is equal or worse compared to some level of severity which we use here to decide on which <code>log</code> macro is appropriate to use when logging the message.</p>
<p>The <code>type_</code> parameter can have the following values:</p>
<ul>
<li><code>vk::DebugUtilsMessageTypeFlagsEXT::GENERAL</code>: Some event has happened that is unrelated to the specification or performance</li>
<li><code>vk::DebugUtilsMessageTypeFlagsEXT::VALIDATION</code>: Something has happened that violates the specification or indicates a possible mistake</li>
<li><code>vk::DebugUtilsMessageTypeFlagsEXT::PERFORMANCE</code>: Potential non-optimal use of Vulkan</li>
</ul>
<p>The <code>pCallbackData</code> parameter refers to a <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.DebugUtilsMessengerCallbackDataEXT.html"><code>vk::DebugUtilsMessengerCallbackDataEXT</code></a> struct containing the details of the message itself, with the most important members being:</p>
<ul>
<li><code>message</code>: The debug message as a null-terminated string (<code>*const c_char</code>)</li>
<li><code>objects</code>: Array of Vulkan object handles related to the message</li>
<li><code>object_count</code>: Number of objects in array</li>
</ul>
<p>Finally, the last parameter, here ignored as <code>_</code>, contains a pointer that was specified during the setup of the callback and allows you to pass your own data to it.</p>
<p>The callback returns a (Vulkan) boolean that indicates if the Vulkan call that triggered the validation layer message should be aborted. If the callback returns true, then the call is aborted with the <code>vk::Result::ERROR_VALIDATION_FAILED_EXT</code> error. This is normally only used to test the validation layers themselves, so you should always return <code>vk::FALSE</code>.</p>
<p>All that remains now is telling Vulkan about the callback function. We'll accomplish this by <em>extending</em> the <code>vk::InstanceCreateInfo</code> struct we used to create the Vulkan instance in the <code>create_instance</code> function with additional instance creation information.</p>
<h2><a class="header" href="#adding-the-debug-callback" id="adding-the-debug-callback">Adding the debug callback</a></h2>
<p>The <code>s_type</code> field that is present on many Vulkan structs was briefly mentioned in the <a href="setup/../overview.html#builders">Builders section</a> of the Overview chapter. It was said that this field must be set to the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.StructureType.html"><code>vk::StructureType</code></a> enum value indicating the type of the struct (e.g., <code>vk::StructureType::APPLICATION_INFO</code> for a <code>vk::ApplicationInfo</code> struct).</p>
<p>You may have wondered what the purpose of this field is; doesn't Vulkan already know the type of structs passed to its commands? The purpose of this field is wrapped up with the purpose of the <code>next</code> field that always accompanies the <code>s_type</code> field in Vulkan structs: the ability to <em>extend</em> a Vulkan struct with other Vulkan structs.</p>
<p>The <code>next</code> field in a Vulkan struct may be used to specify a <a href="https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html#fundamentals-validusage-pNext">structure pointer chain</a>. <code>next</code> can be either be null or a pointer to a Vulkan struct that is permitted by Vulkan to extend the struct. Each struct in this chain of structs is used to provide additional information to the Vulkan command the root structure is passed to. This feature of Vulkan allows for extending the functionality of Vulkan commands without breaking backwards compabilitity.</p>
<p>When you pass such a chain of structs to a Vulkan command, it must iterate through the structs to collect all of the information from the structs. Because of this, Vulkan can't know the type of each structure in the chain, hence the need for the <code>s_type</code> field.</p>
<p>The builder structs provided by <code>vulkanalia</code> allow for easily building these pointer chains in a type-safe manner. For example, take a look at the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.InstanceCreateInfoBuilder.html"><code>vk::InstanceCreateInfoBuilder</code></a> builder struct, specifically the <code>push_next</code> method. This method allows adding any Vulkan struct for which the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.ExtendsInstanceCreateInfo.html"><code>vk::ExtendsInstanceCreateInfo</code></a> trait is implemented for to the pointer chain for a <code>vk::InstanceCreateInfo</code>.</p>
<p>One such struct is <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/struct.DebugUtilsMessengerCreateInfoEXT.html"><code>vk::DebugUtilsMessengerCreateInfoEXT</code></a>, which we will now use to extend our <code>vk::InstanceCreateInfo</code> struct to set up our debug callback. To do this we'll continue to modify our <code>create_instance</code> function, this time making the <code>info</code> variable mutable and then building and pushing a <code>vk::DebugUtilsMessengerCreateInfoEXT</code> struct onto its pointer chain:</p>
<pre><code class="language-rust noplaypen">let mut info = vk::InstanceCreateInfo::builder()
    .application_info(&amp;application_info)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions);

let mut debug_info = vk::DebugUtilsMessengerCreateInfoEXT::builder()
    .message_severity(vk::DebugUtilsMessageSeverityFlagsEXT::all())
    .message_type(vk::DebugUtilsMessageTypeFlagsEXT::all())
    .user_callback(Some(debug_callback));

if VALIDATION_ENABLED {
    info = info.push_next(&amp;mut debug_info);
}
</code></pre>
<p><code>debug_info</code> needs to be defined outside of the conditional since it needs to live until we are done calling <code>entry.create_instance(...)</code>. Fortunately we can rely on the Rust compiler to protect us from pushing a struct that doesn't live long enough onto a pointer chain due to the lifetimes defined for the <code>vulkanalia</code> builder structs.</p>
<p>Now we should be able to run our program and see logs from our debug callback, but first we'll need to set the <code>RUST_LOG</code> environment variable so that <code>pretty_env_logger</code> will enable the log levels we are interested in. Initially set the log level to <code>debug</code> so we can be sure it is working, here is an example on Windows (Powershell):</p>
<p><img src="setup/../images/validation_layer_test.png" alt="" /></p>
<p>If everything is working you shouldn't see any warning or error messages. Going forward you may want to increase the minimum log level to <code>info</code> using <code>RUST_LOG</code> to reduce the verbosity of the logs unless you are trying to debug an error.</p>
<h2><a class="header" href="#configuration" id="configuration">Configuration</a></h2>
<p>There are a lot more settings for the behavior of validation layers than just
the flags specified in the <code>vk::DebugUtilsMessengerCreateInfoEXT</code> struct. Browse
to the Vulkan SDK and go to the <code>Config</code> directory. There you will find a
<code>vk_layer_settings.txt</code> file that explains how to configure the layers.</p>
<p>To configure the layer settings for your own application, copy the file to the
working directory of your project's executable and follow the instructions to
set the desired behavior. However, for the remainder of this tutorial I'll
assume that you're using the default settings.</p>
<p>Throughout this tutorial I'll be making a couple of intentional mistakes to show
you how helpful the validation layers are with catching them and to teach you
how important it is to know exactly what you're doing with Vulkan. Now it's time
to look at Vulkan devices in the system.</p>
<h1><a class="header" href="#physical-devices-and-queue-families" id="physical-devices-and-queue-families">Physical devices and queue families</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/03_physical_device_selection.rs">main.rs</a></p>
<p>After initializing the Vulkan library through an <code>Instance</code> we need to look for and select a graphics card in the system that supports the features we need. In fact we can select any number of graphics cards and use them simultaneously, but in this tutorial we'll stick to the first graphics card that suits our needs.</p>
<p>We'll add a <code>pick_physical_device</code> function which will accomplish this task and write the physical device and related information to an instance of <code>AppData</code>. We'll also need a <code>data: AppData</code> field in our <code>App</code> struct which will be used to store all of the Vulkan objects and related properties for our app. With this in place we can construct and populate an <code>AppData</code> instance in our <code>App::create</code> method.</p>
<pre><code class="language-rust noplaypen">struct App {
    // ...
    data: AppData,
}

impl App {
    fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...

        let mut data = AppData::default();
        pick_physical_device(&amp;instance, &amp;mut data)?;

        Ok(Self { entry, instance, data })
    }
}

fn pick_physical_device(instance: &amp;Instance, data: &amp;mut AppData) -&gt; Result&lt;()&gt; {
    Ok(())
}
</code></pre>
<p>The graphics card that we'll end up selecting will be stored in a <code>vk::PhysicalDevice</code> handle that is added as a new field to the <code>AppData</code> struct. This object will be implicitly destroyed when the <code>Instance</code> is destroyed, so we won't need to do anything new in the <code>App::destroy</code> method.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    physical_device: vk::PhysicalDevice,
}
</code></pre>
<h2><a class="header" href="#device-suitability" id="device-suitability">Device suitability</a></h2>
<p>We'll need a way to determine whether a physical device meets our needs. We'll start by creating a function that returns whether a supplied physical device supports everything we require:</p>
<pre><code class="language-rust noplaypen">fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;bool&gt; {
    Ok(true)
}
</code></pre>
<p>To evaluate whether a physical device meets our needs we can start by querying for some details. Basic device properties like the name, type, and supported Vulkan version can be queried using <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_properties"><code>vk::InstanceV1_0::get_physical_device_properties</code></a>:</p>
<pre><code class="language-rust noplaypen">let properties = instance
    .get_physical_device_properties(physical_device);
</code></pre>
<p>The support for optional features like texture compression, 64 bit floats, and multi viewport rendering (useful for VR) can be queried using <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.InstanceV1_0.html#method.get_physical_device_features"><code>vk::InstanceV1_0::get_physical_device_features</code></a>:</p>
<pre><code class="language-rust noplaypen">let features = instance
    .get_physical_device_features(physical_device);
</code></pre>
<p>There are more details that can be queried from devices that we'll discuss later concerning device memory and queue families (see the next section).</p>
<p>As an example, let's say we consider our application only usable for dedicated graphics cards that support geometry shaders. Then the <code>check_physical_device</code> function would look like this:</p>
<pre><code class="language-rust noplaypen">fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;bool&gt; {
    let properties = instance.get_physical_device_properties(physical_device);
    let features = instance.get_physical_device_features(physical_device);
    Ok(
        properties.device_type == vk::PhysicalDeviceType::DISCRETE_GPU
            &amp;&amp; features.geometry_shader == vk::TRUE,
    )
}
</code></pre>
<p>Instead of just checking if a device is suitable or not and going with the first one, you could also give each device a score and pick the highest one. That way you could favor a dedicated graphics card by giving it a higher score, but fall back to an integrated GPU if that's the only available one. You could also just display the names of the choices and allow the user to select.</p>
<p>Next we'll discuss the first real required feature.</p>
<h2><a class="header" href="#queue-families" id="queue-families">Queue families</a></h2>
<p>It has been briefly touched upon before that almost every operation in Vulkan, anything from drawing to uploading textures, requires commands to be submitted to a queue. There are different types of queues that originate from different queue families and each family of queues allows only a subset of commands. For example, there could be a queue family that only allows processing of compute commands or one that only allows memory transfer related commands.</p>
<p>We need to check which queue families are supported by the device and which one of these supports the commands that we want to use. For that purpose we'll add a new struct <code>QueueFamilyIndices</code> that stores the indices of the queue families we need.</p>
<p>Right now we are only going to look for a queue that supports graphics commands, so the struct and its implementation will look like this:</p>
<pre><code class="language-rust noplaypen">#[derive(Copy, Clone, Debug)]
struct QueueFamilyIndices {
    graphics: u32,
}

impl QueueFamilyIndices {
    fn get(
        instance: &amp;Instance,
        data: &amp;AppData,
        physical_device: vk::PhysicalDevice,
    ) -&gt; Result&lt;Self&gt; {
        let properties = instance
            .get_physical_device_queue_family_properties(physical_device);

        let graphics = properties
            .iter()
            .position(|p| p.queue_flags.contains(vk::QueueFlags::GRAPHICS))
            .map(|i| i as u32);

        if let Some(graphics) = graphics {
            Ok(Self { graphics })
        } else {
            Err(anyhow!(&quot;Failed to get required queue family indices.&quot;))
        }
    }
}
</code></pre>
<p>The queue properties returned by <code>instance.get_physical_device_queue_family_properties(...)</code> contains various details about the queue families supported by the physical device, including the type of operations supported and the number of queues that can be created based on that family. Here we are looking for the first queue family that supports graphics operations as indicated by <code>vk::QueueFlags::GRAPHICS</code>.</p>
<p>Now that we have this fancy queue family lookup method, we can use it as a check in the <code>check_physical_device</code> function to ensure the device can process the commands we want to use:</p>
<pre><code class="language-rust noplaypen">fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;bool&gt; {
    QueueFamilyIndices::get(instance, data, physical_device)?;
    Ok(true)
}
</code></pre>
<p>Lastly we can iterate over the physical devices and pick the first that satisfies our requirements as indicated by <code>check_physical_device</code>. To do this, add the following code to <code>pick_physical_device</code>:</p>
<pre><code class="language-rust noplaypen">data.physical_device = instance
    .enumerate_physical_devices()?
    .into_iter()
    .find(|pd| match check_physical_device(instance, data, *pd) {
        Ok(suitable) =&gt; suitable,
        Err(e) =&gt; {
            warn!(&quot;Failed to check physical device suitability: {}&quot;, e);
            false
        }
    })
    .ok_or_else(|| anyhow!(&quot;Failed to find suitable physical device.&quot;))?;
</code></pre>
<p>Great, that's all we need for now to find the right physical device! The next step is to create a logical device to interface with it.</p>
<h1><a class="header" href="#logical-device-and-queues" id="logical-device-and-queues">Logical device and queues</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/04_logical_device.rs">main.rs</a></p>
<p>After selecting a physical device to use we need to set up a logical device to interface with it. The logical device creation process is similar to the instance creation process and describes the features we want to use. We also need to specify which queues to create now that we've queried which queue families are available. You can even create multiple logical devices from the same physical device if you have varying requirements.</p>
<p>Start by adding a new <code>App</code> field to store the logical device in:</p>
<pre><code class="language-rust noplaypen">struct App {
    // ...
    device: Device,
}
</code></pre>
<p>Next, add a <code>create_logical_device</code> function that is called from <code>App:create</code> and add the resulting logical device to the <code>App</code> initializer:</p>
<pre><code class="language-rust noplaypen">impl App {
    fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...

        let device = create_logical_device(&amp;instance, &amp;mut data)?;

        Ok(Self { entry, instance, data, device })
    }
}

fn create_logical_device(instance: &amp;Instance, data: &amp;mut AppData) -&gt; Result&lt;Device&gt; {
}
</code></pre>
<h2><a class="header" href="#specifying-the-queues-to-be-created" id="specifying-the-queues-to-be-created">Specifying the queues to be created</a></h2>
<p>The creation of a logical device involves specifying a bunch of details in structs again, of which the first one will be <code>vk::DeviceQueueCreateInfo</code>. This structure describes the number of queues we want for a single queue family. Right now we're only interested in a queue with graphics capabilities.</p>
<pre><code class="language-rust noplaypen">let indices = QueueFamilyIndices::get(instance, data, data.physical_device)?;

let queue_priorities = &amp;[1.0];
let queue_info = vk::DeviceQueueCreateInfo::builder()
    .queue_family_index(indices.graphics)
    .queue_priorities(queue_priorities);
</code></pre>
<p>The currently available drivers will only allow you to create a small number of queues for each queue family and you don't really need more than one. That's because you can create all of the command buffers on multiple threads and then submit them all at once on the main thread with a single low-overhead call.</p>
<p>Vulkan lets you assign priorities to queues to influence the scheduling of command buffer execution using floating point numbers between <code>0.0</code> and <code>1.0</code>. This is required even when only creating a single queue.</p>
<h2><a class="header" href="#specifying-the-layers-to-enable" id="specifying-the-layers-to-enable">Specifying the layers to enable</a></h2>
<p>The next piece of information we need to provide bears a resemblance to the <code>vk::CreateInstanceInfo</code> struct. Once again we need to specify any layers or extensions we want to enable, but this time any specified extensions are device specific rather than global.</p>
<p>An example of a device specific extension is <code>VK_KHR_swapchain</code>, which allows you to present rendered images from that device to windows. It is possible that there are Vulkan devices in the system that lack this ability, for example because they only support compute operations. We will come back to this extension in the swap chain chapter.</p>
<p>Previous implementations of Vulkan made a distinction between instance and device specific validation layers, but this is no longer the case. That means that the layer names we pass to <code>enabled_layer_names</code> later are ignored by up-to-date implementations. However, it is still a good idea to set them anyway to be compatible with older implementations.</p>
<p>We wont be enabling any device extensions yet, so we will just construct a list of layer names containing the validation layer if validation is enabled.</p>
<pre><code class="language-rust noplaypen">let layers = if VALIDATION_ENABLED {
    vec![VALIDATION_LAYER.to_cstr().as_ptr()]
} else {
    vec![]
};
</code></pre>
<h2><a class="header" href="#specifying-used-device-features" id="specifying-used-device-features">Specifying used device features</a></h2>
<p>The next information to specify is the set of device features that we'll be using. These are the features that we queried support for with <code>vk::InstanceV1_0::get_physical_device_features</code> in the previous chapter, like geometry shaders. Right now we don't need anything special, so we can simply define it and leave everything to the default values (<code>false</code>). We'll come back to this structure once we're about to start doing more interesting things with Vulkan.</p>
<pre><code class="language-rust noplaypen">let features = vk::PhysicalDeviceFeatures::builder();
</code></pre>
<h2><a class="header" href="#creating-the-logical-device" id="creating-the-logical-device">Creating the logical device</a></h2>
<p>With the previous two structures and the validation layer (if enabled) in place, we can fill in the main <code>vk::DeviceCreateInfo</code> structure.</p>
<pre><code class="language-rust noplaypen">let queue_infos = &amp;[queue_info];
let info = vk::DeviceCreateInfo::builder()
    .queue_create_infos(queue_infos)
    .enabled_layer_names(&amp;layers)
    .enabled_features(&amp;features);
</code></pre>
<p>That's it, we're now ready to instantiate the logical device with a call to the appropriately named <a href="https://docs.rs/vulkanalia/latest/vulkanalia/struct.Instance.html#method.create_device"><code>Instance::create_device</code></a> method.</p>
<pre><code class="language-rust noplaypen">let device = instance.create_device(data.physical_device, &amp;info, None)?;
</code></pre>
<p>The parameters are the physical device to interface with, the queue and usage info we just specified, and the optional allocation callbacks. Similarly to the instance creation function, this call can return errors based on enabling non-existent extensions or specifying the desired usage of unsupported features.</p>
<p>The device should be destroyed in <code>App::destroy</code>:</p>
<pre><code class="language-rust noplaypen">fn destroy(&amp;mut self) {
    self.device.destroy_device(None);
    // ...
}
</code></pre>
<p>Logical devices don't interact directly with instances, which is why it's not included as a parameter.</p>
<h2><a class="header" href="#retrieving-queue-handles" id="retrieving-queue-handles">Retrieving queue handles</a></h2>
<p>The queues are automatically created along with the logical device, but we don't have a handle to interface with them yet. First add a new <code>AppData</code> field to store a handle to the graphics queue:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    graphics_queue: vk::Queue,
}
</code></pre>
<p>Device queues are implicitly cleaned up when the device is destroyed, so we don't need to do anything in <code>App::destroy</code>.</p>
<p>We can use the <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.DeviceV1_0.html#method.get_device_queue"><code>DeviceV1_0::get_device_queue</code></a> function to retrieve queue handles for each queue family. The parameters are the logical device, queue family, and queue index. Because we're only creating a single queue from this family, we'll simply use index 0.</p>
<pre><code class="language-rust noplaypen">data.graphics_queue = device.get_device_queue(indices.graphics, 0);
</code></pre>
<p>Lastly, return the created logical device from <code>create_logical_device</code>:</p>
<pre><code class="language-rust noplaypen">Ok(device)
</code></pre>
<p>With the logical device and queue handles we can now actually start using the graphics card to do things! In the next few chapters we'll set up the resources to present results to the window system.</p>
<h1><a class="header" href="#window-surface" id="window-surface">Window surface</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/05_window_surface.rs">main.rs</a></p>
<p>Since Vulkan is a platform agnostic API, it can not interface directly with the window system on its own. To establish the connection between Vulkan and the window system to present results to the screen, we need to use the WSI (Window System Integration) extensions. In this chapter we'll discuss the first one, which is <code>VK_KHR_surface</code>. It exposes a <code>vk::SurfaceKHR</code> object that represents an abstract type of surface to present rendered images to. The surface in our program will be backed by the window that we've already opened with <code>winit</code>.</p>
<p>The <code>VK_KHR_surface</code> extension is an instance level extension and we've actually already enabled it, because it's included in the list returned by <code>vk_winit::get_required_instance_extensions</code>. The list also includes some other WSI extensions that we'll use in the next couple of chapters.</p>
<p>The window surface needs to be created right after the instance creation, because it can actually influence the physical device selection. The reason we postponed this is because window surfaces are part of the larger topic of render targets and presentation for which the explanation would have cluttered the basic setup. It should also be noted that window surfaces are an entirely optional component in Vulkan, if you just need off-screen rendering. Vulkan allows you to do that without hacks like creating an invisible window (necessary for OpenGL).</p>
<p>While we can freely import types for extensions like the struct <code>vk::SurfaceKHR</code>, we need to import the <code>vulkanalia</code> extension trait for <code>VK_KHR_surface</code> before we can call any of the Vulkan commands added by the extension. Add the following import for <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.KhrSurfaceExtension.html"><code>vk::KhrSurfaceExtension</code></a>:</p>
<pre><code class="language-rust noplaypen">use vulkanalia::vk::KhrSurfaceExtension;
</code></pre>
<h2><a class="header" href="#window-surface-creation" id="window-surface-creation">Window surface creation</a></h2>
<p>Start by adding a <code>surface</code> field in <code>AppData</code> above the other fields.</p>
<pre><code class="language-rust noplaypen">struct AppData {
    surface: vk::SurfaceKHR,
    // ...
}
</code></pre>
<p>Although the <code>vk::SurfaceKHR</code> object and its usage is platform agnostic, its creation isn't because it depends on window system details. For example, it needs the <code>HWND</code> and <code>HMODULE</code> handles on Windows. Therefore there is a platform-specific addition to the extension, which on Windows is called <code>VK_KHR_win32_surface</code> and is also automatically included in the list from <code>vk_winit::get_required_instance_extensions</code>.</p>
<p>I will demonstrate how this platform specific extension can be used to create a surface on Windows, but we won't actually use it in this tutorial. It doesn't make any sense to use a library like GLFW and then proceed to use platform-specific code anyway. <code>vulkanalia</code> has <a href="https://docs.rs/vulkanalia/latest/vulkanalia/winit/fn.create_surface.html"><code>vk_winit::create_surface</code></a> that handles the platform differences for us. Still, it's good to see what it does behind the scenes before we start relying on it.</p>
<p>Because a window surface is a Vulkan object, it comes with a <code>vk::Win32SurfaceCreateInfoKHR</code> struct that needs to be filled in. It has two important parameters: <code>hinstance</code> and <code>hwnd</code>. These are the handles to the process and the window.</p>
<pre><code class="language-rust noplaypen">use winit::platform::windows::WindowExtWindows;

let info = vk::Win32SurfaceCreateInfoKHR::builder()
    .hinstance(window.hinstance())
    .hwnd(window.hwnd());
</code></pre>
<p>The <code>WindowExtWindows</code> trait is imported from <code>winit</code> because it allows us to access platform-specific methods on the <code>winit</code> <code>Window</code> struct. In this case, it permits us to get the process and window handles for the window created by <code>winit</code>.</p>
<p>After that the surface can be created with <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.KhrWin32SurfaceExtension.html#method.create_win32_surface_khr"><code>vk::KhrWin32SurfaceExtension::create_win32_surface_khr</code></a>, which includes parameters for the surface creation details and custom allocators. Technically this is a WSI extension function, but it is so commonly used that the standard Vulkan loader includes it, so unlike other extensions you don't need to explicitly load it. However, we do need to import the <code>vulkanalia</code> extension trait for <code>VK_KHR_win32_surface</code>.</p>
<pre><code class="language-rust noplaypen">use vk::KhrWin32SurfaceExtension;

let surface = instance.create_win32_surface_khr(&amp;info, None).unwrap();
</code></pre>
<p>The process is similar for other platforms like Linux, where <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.KhrXcbSurfaceExtension.html#method.create_xcb_surface_khr"><code>vk::KhrXcbSurfaceExtension::create_xcb_surface_khr</code></a> takes an XCB connection and window as creation details with X11.</p>
<p>The <code>vk_winit::create_surface</code> function performs exactly this operation with a different implementation for each platform. We'll now integrate it into our program. Add a call to the function in <code>App::create</code> right before we pick a physical device.</p>
<pre><code class="language-rust noplaypen">impl App {
    fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...

        let mut data = AppData::default();
        data.surface = vk_winit::create_surface(&amp;instance, window)?;
        pick_physical_device(&amp;instance, &amp;mut data)?;

        // ...
    }
}
</code></pre>
<p>The parameters are the Vulkan instance and the <code>winit</code> window. Once we have our surface, it can be destroyed in <code>App::destroy</code> using the Vulkan API:</p>
<pre><code class="language-rust noplaypen">impl App {
    fn destroy(&amp;mut self) {
        // ...
        self.instance.destroy_surface_khr(self.data.surface, None);
        self.instance.destroy_instance(None);
    }
}
</code></pre>
<p>Make sure that the surface is destroyed before the instance.</p>
<h2><a class="header" href="#querying-for-presentation-support" id="querying-for-presentation-support">Querying for presentation support</a></h2>
<p>Although the Vulkan implementation may support window system integration, that does not mean that every device in the system supports it. Therefore we need to extend the <code>QueueFamilyIndices</code> struct to ensure that a device can present images to the surface we created. Since the presentation is a queue-specific feature, the problem is actually about finding a queue family that supports presenting to the surface we created.</p>
<p>It's actually possible that the queue families supporting drawing commands and the ones supporting presentation do not overlap. Therefore we have to take into account that there could be a distinct presentation queue by modifying the <code>QueueFamilyIndices</code> struct:</p>
<pre><code class="language-rust noplaypen">struct QueueFamilyIndices {
    graphics: u32,
    present: u32,
}
</code></pre>
<p>Next, we'll modify the <code>QueueFamilyIndices::get</code> method to look for a queue family that has the capability of presenting to our window surface. The function to check for that is <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.KhrSurfaceExtension.html#method.get_physical_device_surface_support_khr"><code>vk::KhrSurfaceExtension::get_physical_device_surface_support_khr</code></a>, which takes the physical device, queue family index. and surface as parameters and returns whether presentation is supported for that combination of physical device, queue family, and surface.</p>
<p>Modify <code>QueueFamilyIndices::get</code> to find a presentation queue family index below where a graphics queue family index is found.</p>
<pre><code class="language-rust noplaypen">let mut present = None;
for (index, properties) in properties.iter().enumerate() {
    if instance.get_physical_device_surface_support_khr(
        physical_device,
        index as u32,
        data.surface,
    )? {
        present = Some(index as u32);
    }
}
</code></pre>
<p>We'll also need to add <code>present</code> to the final expression:</p>
<pre><code class="language-rust noplaypen">if let (Some(graphics), Some(present)) = (graphics, present) {
    Ok(Self { graphics, present })
} else {
    Err(anyhow!(&quot;Failed to get required queue family indices.&quot;))
}
</code></pre>
<p>Note that it's very likely that these end up being the same queue family after all, but throughout the program we will treat them as if they were separate queues for a uniform approach. Nevertheless, you could add logic to explicitly prefer a physical device that supports drawing and presentation in the same queue for improved performance.</p>
<h2><a class="header" href="#creating-the-presentation-queue" id="creating-the-presentation-queue">Creating the presentation queue</a></h2>
<p>The one thing that remains is modifying the logical device creation procedure to create the presentation queue and retrieve the <code>VkQueue</code> handle. Add a field to <code>AppData</code> for the handle:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    present_queue: vk::Queue,
}
</code></pre>
<p>Next, we need to have multiple <code>vk::DeviceQueueCreateInfo</code> structs to create a queue from both families. An elegant way to do that is to create a set of all unique queue families that are necessary for the required queues. We'll do this in the <code>create_logical_device</code> function:</p>
<pre><code class="language-rust noplaypen">let indices = QueueFamilyIndices::get(instance, data, data.physical_device)?;

let mut unique_indices = HashSet::new();
unique_indices.insert(indices.graphics);
unique_indices.insert(indices.present);

let queue_priorities = &amp;[1.0];
let queue_infos = unique_indices
    .iter()
    .map(|i| {
        vk::DeviceQueueCreateInfo::builder()
            .queue_family_index(*i)
            .queue_priorities(queue_priorities)
    })
    .collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<p>And delete the previous <code>queue_infos</code> slice and take a reference to the <code>queue_infos</code> list for <code>vk::DeviceCreateInfo</code>:</p>
<pre><code class="language-rust noplaypen">let info = vk::DeviceCreateInfo::builder()
    .queue_create_infos(&amp;queue_infos)
    .enabled_layer_names(&amp;layers)
    .enabled_features(&amp;features);
</code></pre>
<p>If the queue families are the same, then we only need to pass its index once. Finally, add a call to retrieve the queue handle:</p>
<pre><code class="language-rust noplaypen">data.present_queue = device.get_device_queue(indices.present, 0);
</code></pre>
<p>In case the queue families are the same, the two handles will most likely have the same value now. In the next chapter we're going to look at swap chains and how they give us the ability to present images to the surface.</p>
<h1><a class="header" href="#swapchain" id="swapchain">Swapchain</a></h1>
<p><strong>Code:</strong> <a href="https://github.com/KyleMayes/vulkanalia/tree/master/tutorial/src/06_swapchain_creation.rs">main.rs</a></p>
<p>Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen. This infrastructure is known as the <em>swap chain</em> and must be created explicitly in Vulkan. The swap chain is essentially a queue of images that are waiting to be presented to the screen. Our application will acquire such an image to draw to it, and then return it to the queue. How exactly the queue works and the conditions for presenting an image from the queue depend on how the swap chain is set up, but the general purpose of the swap chain is to synchronize the presentation of images with the refresh rate of the screen.</p>
<h2><a class="header" href="#checking-for-swap-chain-support" id="checking-for-swap-chain-support">Checking for swap chain support</a></h2>
<p>Not all graphics cards are capable of presenting images directly to a screen for various reasons, for example because they are designed for servers and don't have any display outputs. Secondly, since image presentation is heavily tied into the window system and the surfaces associated with windows, it is not actually part of the Vulkan core. You have to enable the <code>VK_KHR_swapchain</code> device extension after querying for its support. Also, like before, you need to import the <code>vulkanalia</code> extension trait for <code>VK_KHR_swapchain</code>:</p>
<pre><code class="language-rust noplaypen">use vulkanalia::vk::KhrSwapchainExtension;
</code></pre>
<p>Then we'll first extend the <code>check_physical_device</code> function to check if this extension is supported. We've previously seen how to list the extensions that are supported by a <code>vk::PhysicalDevice</code>, so doing that should be fairly straightforward.</p>
<p>First declare a list of required device extensions, similar to the list of validation layers to enable.</p>
<pre><code class="language-rust noplaypen">const DEVICE_EXTENSIONS: &amp;[vk::ExtensionName] = &amp;[vk::KHR_SWAPCHAIN_EXTENSION];
</code></pre>
<p>Next, create a new function <code>check_physical_device_extensions</code> that is called from <code>check_physical_device</code> as an additional check:</p>
<pre><code class="language-rust noplaypen">fn check_physical_device(
    instance: &amp;Instance,
    data: &amp;AppData,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;bool&gt; {
    QueueFamilyIndices::get(instance, data, physical_device)?;
    let extensions = check_physical_device_extensions(instance, physical_device)?;
    Ok(extensions)
}

fn check_physical_device_extensions(
    instance: &amp;Instance,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;bool&gt; {
    Ok(true)
}
</code></pre>
<p>Modify the body of the function to enumerate the extensions and check if all of the required extensions are amongst them.</p>
<pre><code class="language-rust noplaypen">fn check_physical_device_extensions(
    instance: &amp;Instance,
    physical_device: vk::PhysicalDevice,
) -&gt; Result&lt;bool&gt; {
    let extensions = instance
        .enumerate_device_extension_properties(physical_device, None)?
        .iter()
        .map(|e| e.extension_name)
        .collect::&lt;HashSet&lt;_&gt;&gt;();
    Ok(DEVICE_EXTENSIONS.iter().all(|e| extensions.contains(e)))
}
</code></pre>
<p>Now run the code and verify that your graphics card is indeed capable of creating a swap chain. It should be noted that the availability of a presentation queue, as we checked in the previous chapter, implies that the swap chain extension must be supported. However, it's still good to be explicit about things, and the extension does have to be explicitly enabled.</p>
<h2><a class="header" href="#enabling-device-extensions" id="enabling-device-extensions">Enabling device extensions</a></h2>
<p>Using a swapchain requires enabling the <code>VK_KHR_swapchain</code> extension first. Enabling the extension just requires a small change to the logical device creation structure in the <code>create_logical_device</code> function, first we'll convert our list of extensions to a list of null-terminated strings:</p>
<pre><code class="language-rust noplaypen">let extensions = DEVICE_EXTENSIONS
    .iter()
    .map(|n| n.to_cstr().as_ptr())
    .collect::&lt;Vec&lt;_&gt;&gt;();
</code></pre>
<p>Then we just need to add the extension names to the <code>vk::DeviceCreateInfo</code> struct:</p>
<pre><code class="language-rust noplaypen">let info = vk::DeviceCreateInfo::builder()
    .queue_create_infos(&amp;queue_infos)
    .enabled_layer_names(&amp;layers)
    .enabled_extension_names(&amp;extensions)
    .enabled_features(&amp;features);
</code></pre>
<h2><a class="header" href="#querying-details-of-swap-chain-support" id="querying-details-of-swap-chain-support">Querying details of swap chain support</a></h2>
<p>Just checking if a swap chain is available is not sufficient, because it may not actually be compatible with our window surface. Creating a swap chain also involves a lot more settings than instance and device creation, so we need to query for some more details before we're able to proceed.</p>
<p>There are basically three kinds of properties we need to check:</p>
<ul>
<li>Basic surface capabilities (min/max number of images in swap chain, min/max width and height of images)</li>
<li>Surface formats (pixel format, color space)</li>
<li>Available presentation modes</li>
</ul>
<p>Similar to <code>QueueFamilyIndices</code>, we'll use a struct to pass these details around once they've been queried. The three aforementioned types of properties come in the form of the following structs and lists of structs:</p>
<pre><code class="language-rust noplaypen">#[derive(Clone, Debug)]
struct SwapchainSupport {
    capabilities: vk::SurfaceCapabilitiesKHR,
    formats: Vec&lt;vk::SurfaceFormatKHR&gt;,
    present_modes: Vec&lt;vk::PresentModeKHR&gt;,
}
</code></pre>
<p>We'll now create a new method <code>SwapchainSupport::get</code> that will initialize this struct with all of the structs we need.</p>
<pre><code class="language-rust noplaypen">impl SwapchainSupport {
    fn get(
        instance: &amp;Instance,
        data: &amp;AppData,
        physical_device: vk::PhysicalDevice,
    ) -&gt; Result&lt;Self&gt; {
        Ok(Self {
            capabilities: instance
                .get_physical_device_surface_capabilities_khr(
                    physical_device, data.surface)?,
            formats: instance
                .get_physical_device_surface_formats_khr(
                    physical_device, data.surface)?,
            present_modes: instance
                .get_physical_device_surface_present_modes_khr(
                    physical_device, data.surface)?,
        })
    }
}
</code></pre>
<p>The meaning of these structs and exactly which data they contain is discussed in the next section.</p>
<p>All of the details are in the struct now, so let's extend <code>check_physical_device</code> once more to utilize this method to verify that swap chain support is adequate. Swap chain support is sufficient for this tutorial if there is at least one supported image format and one supported presentation mode given the window surface we have.</p>
<pre><code class="language-rust noplaypen">let support = SwapchainSupport::get(instance, data, physical_device)?;
let swapchain = !support.formats.is_empty() &amp;&amp; !support.present_modes.is_empty();
</code></pre>
<p>It is important that we only try to query for swap chain support after verifying that the extension is available. The last line of the function changes to:</p>
<pre><code class="language-rust noplaypen">Ok(extensions &amp;&amp; swapchain)
</code></pre>
<h2><a class="header" href="#choosing-the-right-settings-for-the-swap-chain" id="choosing-the-right-settings-for-the-swap-chain">Choosing the right settings for the swap chain</a></h2>
<p>If the conditions we just added were met then the support is definitely sufficient, but there may still be many different modes of varying optimality. We'll now write a couple of functions to find the right settings for the best possible swap chain. There are three types of settings to determine:</p>
<ul>
<li>Surface format (color depth)</li>
<li>Presentation mode (conditions for &quot;swapping&quot; images to the screen)</li>
<li>Swap extent (resolution of images in swap chain)</li>
</ul>
<p>For each of these settings we'll have an ideal value in mind that we'll go with if it's available and otherwise we'll create some logic to find the next best thing.</p>
<h3><a class="header" href="#surface-format" id="surface-format">Surface format</a></h3>
<p>The function for this setting starts out like this. We'll later pass the <code>formats</code> field of the <code>SwapchainSupport</code> struct as argument.</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_surface_format(
    formats: &amp;[vk::SurfaceFormatKHR],
) -&gt; vk::SurfaceFormatKHR {
}
</code></pre>
<p>Each <code>vk::SurfaceFormatKHR</code> entry contains a <code>format</code> and a <code>color_space</code> member. The <code>format</code> member specifies the color channels and types. For example, <code>vk::Format::B8G8R8A8_SRGB</code> means that we store the B, G, R and alpha channels in that order with an 8 bit unsigned integer for a total of 32 bits per pixel. The <code>color_space</code> member indicates if the SRGB color space is supported or not using the <code>vk::ColorSpace::SRGB_NONLINEAR_KHR</code> flag.</p>
<p>For the color space we'll use SRGB if it is available, because it <a href="http://stackoverflow.com/questions/12524623/">results in more accurate perceived colors</a>. It is also pretty much the standard color space for images, like the textures we'll use later on. Because of that we should also use an SRGB color format, of which one of the most common ones is <code>vk::Format::B8G8R8A8_SRGB</code>.</p>
<p>Let's go through the list and see if the preferred combination is available:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_surface_format(
    formats: &amp;[vk::SurfaceFormatKHR],
) -&gt; vk::SurfaceFormatKHR {
    formats
        .iter()
        .cloned()
        .find(|f| {
            f.format == vk::Format::B8G8R8A8_SRGB
                &amp;&amp; f.color_space == vk::ColorSpaceKHR::SRGB_NONLINEAR
        })
        .unwrap_or_else(|| formats[0])
}
</code></pre>
<p>If that also fails then we could rank the available formats based on how &quot;good&quot; they are, but in most cases it's okay to just settle with the first format that is specified hence <code>.unwrap_or_else(|| formats[0])</code>.</p>
<h3><a class="header" href="#presentation-mode" id="presentation-mode">Presentation mode</a></h3>
<p>The presentation mode is arguably the most important setting for the swap chain, because it represents the actual conditions for showing images to the screen. There are four possible modes available in Vulkan:</p>
<ul>
<li><code>vk::PresentModeKHR::IMMEDIATE</code>: Images submitted by your application are transferred to the screen right away, which may result in tearing.</li>
<li><code>vk::PresentModeKHR::FIFO</code>: The swap chain is a queue where the display takes an image from the front of the queue when the display is refreshed and the program inserts rendered images at the back of the queue. If the queue is full then the program has to wait. This is most similar to vertical sync as found in modern games. The moment that the display is refreshed is known as &quot;vertical blank&quot;.</li>
<li><code>vk::PresentModeKHR::FIFO_RELAXED</code>: This mode only differs from the previous one if the application is late and the queue was empty at the last vertical blank. Instead of waiting for the next vertical blank, the image is transferred right away when it finally arrives. This may result in visible tearing.</li>
<li><code>vk::PresentModeKHR::MAILBOX</code>: This is another variation of the second mode. Instead of blocking the application when the queue is full, the images that are already queued are simply replaced with the newer ones. This mode can be used to implement triple buffering, which allows you to avoid tearing with significantly less latency issues than standard vertical sync that uses double buffering.</li>
</ul>
<p>Only the <code>vk::PresentModeKHR::FIFO</code> mode is guaranteed to be available, so we'll again have to write a function that looks for the best mode that is available:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_present_mode(
    present_modes: &amp;[vk::PresentModeKHR],
) -&gt; vk::PresentModeKHR {
}
</code></pre>
<p>I personally think that triple buffering is a very nice trade-off. It allows us to avoid tearing while still maintaining a fairly low latency by rendering new images that are as up-to-date as possible right until the vertical blank. So, let's look through the list to see if it's available and fall back to FIFO if it isn't:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_present_mode(
    present_modes: &amp;[vk::PresentModeKHR],
) -&gt; vk::PresentModeKHR {
    present_modes
        .iter()
        .cloned()
        .find(|m| *m == vk::PresentModeKHR::MAILBOX)
        .unwrap_or(vk::PresentModeKHR::FIFO)
}
</code></pre>
<h3><a class="header" href="#swap-extent" id="swap-extent">Swap extent</a></h3>
<p>That leaves only one major property, for which we'll add one last function:</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_extent(
    window: &amp;Window,
    capabilities: vk::SurfaceCapabilitiesKHR.
) -&gt; vk::Extent2D {
}
</code></pre>
<p>The swap extent is the resolution of the swap chain images and it's almost always exactly equal to the resolution of the window that we're drawing to. The range of the possible resolutions is defined in the <code>vk::SurfaceCapabilitiesKHR</code> structure. Vulkan tells us to match the resolution of the window by setting the width and height in the <code>current_extent</code> member. However, some window managers do allow us to differ here and this is indicated by setting the width and height in <code>current_extent</code> to a special value: the maximum value of <code>u32</code>. In that case we'll pick the resolution that best matches the window within the <code>min_image_extent</code> and <code>max_image_extent</code> bounds.</p>
<pre><code class="language-rust noplaypen">fn get_swapchain_extent(
    window: &amp;Window,
    capabilities: vk::SurfaceCapabilitiesKHR,
) -&gt; vk::Extent2D {
    if capabilities.current_extent.width != u32::max_value() {
        capabilities.current_extent
    } else {
        let size = window.inner_size();
        let clamp = |min: u32, max: u32, v: u32| min.max(max.min(v));
        vk::Extent2D::builder()
            .width(clamp(
                capabilities.min_image_extent.width,
                capabilities.max_image_extent.width,
                size.width,
            ))
            .height(clamp(
                capabilities.min_image_extent.height,
                capabilities.max_image_extent.height,
                size.height,
            ))
            .build()
    }
}
</code></pre>
<p>We define the <code>clamp</code> function to restrict the actual size of the window within the supported range supported by the Vulkan device.</p>
<h2><a class="header" href="#creating-the-swap-chain" id="creating-the-swap-chain">Creating the swap chain</a></h2>
<p>Now that we have all of these helper functions assisting us with the choices we have to make at runtime, we finally have all the information that is needed to create a working swap chain.</p>
<p>Create a <code>create_swapchain</code> function that starts out with the results of these calls and make sure to call it from <code>App::create</code> after logical device creation.</p>
<pre><code class="language-rust noplaypen">impl App {
    fn create(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        // ...

        let device = create_logical_device(&amp;instance, &amp;mut data)?;
        create_swapchain(window, &amp;instance, &amp;device, &amp;mut data)?;

        // ...
    }
}

fn create_swapchain(
    window: &amp;Window,
    instance: &amp;Instance,
    device: &amp;Device,
    data: &amp;mut AppData,
) -&gt; Result&lt;()&gt; {
    let indices = QueueFamilyIndices::get(instance, data, data.physical_device)?;
    let support = SwapchainSupport::get(instance, data, data.physical_device)?;

    let surface_format = get_swapchain_surface_format(&amp;support.formats);
    let present_mode = get_swapchain_present_mode(&amp;support.present_modes);
    let extent = get_swapchain_extent(window, support.capabilities);

    Ok(())
}
</code></pre>
<p>Aside from these properties we also have to decide how many images we would like to have in the swap chain. The implementation specifies the minimum number that it requires to function:</p>
<pre><code class="language-rust noplaypen">let image_count = support.capabilities.min_image_count;
</code></pre>
<p>However, simply sticking to this minimum means that we may sometimes have to wait on the driver to complete internal operations before we can acquire another image to render to. Therefore it is recommended to request at least one more image than the minimum:</p>
<pre><code class="language-rust noplaypen">let image_count = support.capabilities.min_image_count + 1;
</code></pre>
<p>We should also make sure to not exceed the maximum number of images while doing this, where <code>0</code> is a special value that means that there is no maximum:</p>
<pre><code class="language-rust noplaypen">let mut image_count = support.capabilities.min_image_count + 1;
if support.capabilities.max_image_count != 0
    &amp;&amp; image_count &gt; support.capabilities.min_image_count
{
    image_count = support.capabilities.max_image_count;
}
</code></pre>
<p>Next, we need to specify how to handle swap chain images that will be used across multiple queue families. That will be the case in our application if the graphics queue family is different from the presentation queue. We'll be drawing on the images in the swap chain from the graphics queue and then submitting them on the presentation queue. There are two ways to handle images that are accessed from multiple queues:</p>
<ul>
<li><code>vk::SharingMode::EXCLUSIVE</code>: An image is owned by one queue family at a time and ownership must be explicitly transferred before using it in another queue family. This option offers the best performance.</li>
<li><code>vk::SharingMode::CONCURRENT</code>: Images can be used across multiple queue families without explicit ownership transfers.</li>
</ul>
<p>If the queue families differ, then we'll be using the concurrent mode in this tutorial to avoid having to do the ownership chapters, because these involve some concepts that are better explained at a later time. Concurrent mode requires you to specify in advance between which queue families ownership will be shared using the <code>queue_family_indices</code> builder struct method If the graphics queue family and presentation queue family are the same, which will be the case on most hardware, then we should stick to exclusive mode, because concurrent mode requires you to specify at least two distinct queue families.</p>
<pre><code class="language-rust noplaypen">let mut queue_family_indices = vec![];
let image_sharing_mode = if indices.graphics != indices.present {
    queue_family_indices.push(indices.graphics);
    queue_family_indices.push(indices.present);
    vk::SharingMode::CONCURRENT
} else {
    vk::SharingMode::EXCLUSIVE
};
</code></pre>
<p>As is tradition with Vulkan objects, creating the swap chain object requires filling in a large structure. It starts out very familiarly:</p>
<pre><code class="language-rust noplaypen">let info = vk::SwapchainCreateInfoKHR::builder()
    .surface(data.surface)
    // continued...
</code></pre>
<p>After specifying which surface the swap chain should be tied to, the details of the swap chain images are specified:</p>
<pre><code class="language-rust noplaypen">    .min_image_count(image_count)
    .image_format(surface_format.format)
    .image_color_space(surface_format.color_space)
    .image_extent(extent)
    .image_array_layers(1)
    .image_usage(vk::ImageUsageFlags::COLOR_ATTACHMENT)
</code></pre>
<p>The <code>image_array_layers</code> specifies the amount of layers each image consists of. This is always <code>1</code> unless you are developing a stereoscopic 3D application. The <code>image_usage</code> bitmask specifies what kind of operations we'll use the images in the swap chain for. In this tutorial we're going to render directly to them, which means that they're used as color attachment. It is also possible that you'll render images to a separate image first to perform operations like post-processing. In that case you may use a value like <code>vk::ImageUsageFlags::TRANSFER_DST</code> instead and use a memory operation to transfer the rendered image to a swap chain image.</p>
<pre><code class="language-rust noplaypen">    .image_sharing_mode(image_sharing_mode)
    .queue_family_indices(&amp;queue_family_indices)
</code></pre>
<p>Next we'll provide the image sharing mode and indices of the queue families permitted to share the swap chain images.</p>
<pre><code class="language-rust noplaypen">    .pre_transform(support.capabilities.current_transform)
</code></pre>
<p>We can specify that a certain transform should be applied to images in the swap chain if it is supported (<code>supported_transforms</code> in <code>capabilities</code>), like a 90 degree clockwise rotation or horizontal flip. To specify that you do not want any transformation, simply specify the current transformation.</p>
<pre><code class="language-rust noplaypen">    .composite_alpha(vk::CompositeAlphaFlagsKHR::OPAQUE)
</code></pre>
<p>The <code>composite_alpha</code> method specifies if the alpha channel should be used for blending with other windows in the window system. You'll almost always want to simply ignore the alpha channel, hence <code>vk::CompositeAlphaFlagsKHR::OPAQUE</code>.</p>
<pre><code class="language-rust noplaypen">    .present_mode(present_mode)
    .clipped(true)
</code></pre>
<p>The <code>present_mode</code> member speaks for itself. If the <code>clipped</code> member is set to <code>true</code> then that means that we don't care about the color of pixels that are obscured, for example because another window is in front of them. Unless you really need to be able to read these pixels back and get predictable results, you'll get the best performance by enabling clipping.</p>
<pre><code class="language-rust noplaypen">    .old_swapchain(vk::SwapchainKHR::null());
</code></pre>
<p>That leaves one last method, <code>old_swapchain</code>. With Vulkan it's possible that your swap chain becomes invalid or unoptimized while your application is running, for example because the window was resized. In that case the swap chain actually needs to be recreated from scratch and a reference to the old one must be specified in this method. This is a complex topic that we'll learn more about in a future chapter. For now we'll assume that we'll only ever create one swap chain. We could omit this method since the underlying field will default to a null handle, but we'll leave it in for completeness.</p>
<p>Now add an <code>AppData</code> field to store the <code>vk::SwapchainKHR</code> object:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    swapchain: vk::SwapchainKHR,
}
</code></pre>
<p>Creating the swap chain is now as simple as calling <a href="https://docs.rs/vulkanalia/latest/vulkanalia/vk/trait.KhrSwapchainExtension.html#method.create_swapchain_khr"><code>vk::KhrSwapchainExtension::create_swapchain</code></a>:</p>
<pre><code class="language-rust noplaypen">data.swapchain = device.create_swapchain_khr(&amp;info, None)?;
</code></pre>
<p>The parameters are the swap chain creation info and optional custom allocators. No surprises there. It should be cleaned up in <code>App::destroy</code> before the device:</p>
<pre><code class="language-rust noplaypen">impl App {
    fn destroy(&amp;mut self) {
        self.device.destroy_swapchain_khr(self.data.swapchain, None);
        // ...
    }
}
</code></pre>
<p>Now run the application to ensure that the swap chain is created successfully! If at this point you get an access violation error in <code>vkCreateSwapchainKHR</code> or see a message like <code>Failed to find 'vkGetInstanceProcAddress' in layer SteamOverlayVulkanLayer.dll</code>, then see the <a href="presentation/../faq.html">FAQ entry</a> about the Steam overlay layer.</p>
<p>Try removing the <code>.image_extent(extent)</code> line from where you are building the <code>vk::SwapchainCreateInfoKHR</code> struct with validation layers enabled. You'll see that one of the validation layers immediately catches the mistake and some helpful messages are printed which call out the illegal value provided for <code>image_extent</code>:</p>
<p><img src="presentation/../images/swap_chain_validation_layer.png" alt="" /></p>
<h2><a class="header" href="#retrieving-the-swap-chain-images" id="retrieving-the-swap-chain-images">Retrieving the swap chain images</a></h2>
<p>The swap chain has been created now, so all that remains is retrieving the handles of the <code>vk::Image</code>s in it. We'll reference these during rendering operations in later chapters. Add an <code>AppData</code> field to store the handles:</p>
<pre><code class="language-rust noplaypen">struct AppData {
    // ...
    swapchain_images: Vec&lt;vk::Image&gt;,
}
</code></pre>
<p>The images were created by the implementation for the swap chain and they will be automatically cleaned up once the swap chain has been destroyed, therefore we don't need to add any cleanup code.</p>
<p>I'm adding the code to retrieve the handles to the end of the <code>create_swapchain</code> function, right after the <code>device.create_swapchain_khr(...)</code> call.</p>
<pre><code class="language-rust noplaypen">data.swapchain_images = device.get_swapchain_images_khr(data.swapchain)?;
</code></pre>
<p>One last thing, store the format and extent we've chosen for the swap chain images in <code>AppData</code> fields. We'll need them in future chapters.</p>
<pre><code class="language-rust noplaypen">impl AppData {
    // ...
    swapchain_format: vk::Format,
    swapchain_extent: vk::Extent2D,
    swapchain: vk::SwapchainKHR,
    swapchain_images: Vec&lt;vk::Image&gt;,
}
</code></pre>
<p>And then in <code>create_swapchain</code>:</p>
<pre><code class="language-rust noplaypen">data.swapchain_format = surface_format.format;
data.swapchain_extent = extent;
</code></pre>
<p>We now have a set of images that can be drawn onto and can be presented to the window. The next chapter will begin to cover how we can set up the images as render targets and then we start looking into the actual graphics pipeline and drawing commands!</p>
<h1><a class="header" href="#image-views" id="image-views">Image views</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#shader-modules" id="shader-modules">Shader modules</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#fixed-functions" id="fixed-functions">Fixed functions</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#render-passes" id="render-passes">Render passes</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#conclusion" id="conclusion">Conclusion</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#framebuffers" id="framebuffers">Framebuffers</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#command-buffers" id="command-buffers">Command buffers</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#rendering-and-presentation" id="rendering-and-presentation">Rendering and presentation</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#recreation" id="recreation">Recreation</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#vertex-input-description" id="vertex-input-description">Vertex input description</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#vertex-buffer-creation" id="vertex-buffer-creation">Vertex buffer creation</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#staging-buffer" id="staging-buffer">Staging buffer</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#index-buffer" id="index-buffer">Index buffer</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#descriptor-layout-and-buffer" id="descriptor-layout-and-buffer">Descriptor layout and buffer</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#descriptor-pool-and-sets" id="descriptor-pool-and-sets">Descriptor pool and sets</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#images" id="images">Images</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#image-view-and-sampler" id="image-view-and-sampler">Image view and sampler</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#combined-image-sampler" id="combined-image-sampler">Combined image sampler</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#depth-buffering" id="depth-buffering">Depth buffering</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#loading-models" id="loading-models">Loading models</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#generating-mipmaps" id="generating-mipmaps">Generating mipmaps</a></h1>
<p>Coming soon™.</p>
<h1><a class="header" href="#multisampling" id="multisampling">Multisampling</a></h1>
<p>Coming soon™.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
